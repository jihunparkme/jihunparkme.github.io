---
layout: post
title: IT Basics
summary: Collect all IT Basics
categories: IT
featured-img: IT
# mathjax: true
---



# Table of Contents

* [JAVA](#JAVA)

- [WEB](#WEB)
- [S/W engineering](#S/W engineering)



# JAVA

### JAVA

**절차지향**

-	POP : Procedure-Oriented Programming

- 실행되는 순서가 위에서부터 아래로 순차적으로 진행되는 형태를 가진 언어
- 프로그램 재사용 시 기존에 만들어진 코드를 복사하여 붙여넣기 하는 방법 사용
- 함수의 등장
  - 자주 사용되는 특정한 코드를 하나의 모듈(묶음)로 묶어 놓은 것
  - 프로그래머가 사용하고 싶을 때마다 호출하여 코드가 실행되도록 함
  - 데이터와 함수 간에 유기적인 관계성을 갖지 못함

**객체지향**

- OOP : Object-Oriented Programming

- 데이터를 객체로 취급하여 프로그램에 반영, 객체와 객체의 상호작용을 통해 프로그램이 동작

- 코드의 재사용성이 높음, 코드 관리가 용이, 코드의 중복을 제거
  - 각각의 객체는 메시지를 주고받고, 데이터를 처리 -> 유지보수성 Good
  - 함수보다 더 높은 모듈 관리를 위해 자신이 가진 고유의 데이터와 그 데이터를 처리할 수 있는 메서드를 가짐
  - 모든 데이터를 객체로 취급하므로 객체와 객체 간 자유로운 데이터 이동 가능

- **객체**(Object) : 현실 세계에 존재하는 유, 무형의 모든 것
- **클래스**(Class) : 현실 세계의 객체를 컴퓨터 메모리에 생성할 수 있는 템플릿

- **인스턴스**(Instance) : 컴퓨터 메모리에 존재하는 객체

<Br>

### 클래스와 객체

- **상속**(Inheritance) : 속성과 메서드가 약간 다른 객체를 필요로 할 때, 기존의 클래스를 이용하여 새로운 클래스를 작성

  - 이미 존재하는 클래스를 바탕으로 필요한 변수와 메서드를 추가로 정의
  - 클래스의 간결화, 클래스 관리 용이, SW 생산성 향상
  -  자바에서는 클래스의 다중 상속을 지원 안함
  - 자바에서는 상속의 횟수에 제한을 두지 않음
  - 자바에서 계층 구조의 최상위에 java.lang.Object 클래스가 있음

- **다형성**(Polymorphism) : 하나의 인터페이스를 이용하여 서로 다른 구현을 제공

  - 메서드 오버로딩(Overloading) : 이름은 동일하지만 입력 항목(인자 개수, 유형)이 다른 메서드
  - 메서드 오버라이딩(Overriding) : 부모 클래스의 메서드를 자식 클래스가 동일한 형태로 덮어쓰기(재정의)

- **추상화**(Abstraction) : 공통적인 특징을 찾아내어 Class를 설계, 구체적인 사실들을 일반화하여 기술

  - ex) S사의 TV, L사의 TV, I사의 TV 를 모두 조작 가능한 리모컨 -> 각 제조사의 리모컨을 일반화하여 하나로 조작

- **캡슐화**(Encapsulation) : 변수와 메서드를 하나의 추상화된 클래스로 묶는 과정

- **정보 은닉**(Information Hiding) : 캡슐화된 클래스 내부의 메서드를 통해서만 변수 조작 가능

- **메시지**(Message) : 객체 간 서로 통신하는 방법

- **생성자**

  - 객체 생성 순간 자동으로 호출되는 메소드
  - 생성자의 이름은 클래스 이름과 동일
  - 여러 개 작성(오버로딩) 가능
  - new를 통해 객체를 생성할 때 한 번 호출
  - 리턴 타입 지정 불가
  - 객체 생성될 때, 필요한 초기 작업을 위함

-  **this()**

  - 클래스 내에서 생성자가 다른 생성자를 호출할 때 사용
  - 생성자 코드에서만 호출 가능
  - 같은 클래스 내 다른 생성자를 호출할 때 사용
  - 생성자의 첫 번째 문장이 되어야 함

- **클래스 접근제어자의 종류와 특성**

  - private : 같은 클래스 내에서만 접근 가능
  - default : 같은 패키지 내에서만 접근 가능

  - protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근 가능
  - public : 접근 제한 없음

  적용 범위 : public > protected > default > private

- **추상클래스** : 이름만 존재하고 기능이 생략된 메서드, 상속을 통해서 자손 클래스에서 오버라이딩하여 구현

- **인터페이스** : 조립 설명서, 일종의 규약, 오직 추상메서드와 상수만을 멤버로 가짐

  - 인터페이스로부터만 상속받을 수 있음, 인터페이스로부터 다중상속 가능
  - 멤버는 추상 메소드와 상수만으로 구성
  - 모든 메소드는 abstract public이며 생략 가능
  - 상수는 public static final 타입이며 생략 가능
  - 인터페이스는 객체 생성 불가
  - 다른 인터페이스에 상속 가능
  - 인터페이스 타입의 레퍼런스 변수는 선언 가능
  - 다중 상속 허용 (extends 키워드)

- **패키지** : 서로 관련된 클래스와 인터페이스의 컴파일 된 클래스 파일들을 하나의 디렉터리에 묶어 놓은 것

  - 하나의 응용프로그램은 여러 개의 패키지로 작성 가능
  - 패키지는 jar 파일로 압출 가능
  - 파일명이 중복되는 문제를 해결 (경로명이 다름)

<br>

- **쓰레드(Thread)**
  - 하나의 작업 단위, 한 프로세스 내에 여러 쓰레드가 존재 가능, 해당 쓰레드들은 프로세스의 자원을 공유
  - 쓰레드 생성 방법

    1. Thread 클래스 상속하기(extends Thread)
    2. Runnable 인터페이스를 implements 하기 (다른 클래스를 상속받은 경우)
    3. 익명 클래스 이용하기 (new Thread()), 쓰레드가 단 한번만 수행

- **프로세스(Process)**
  - 운영체제에서 실행중인 하나의 프로그램(하나 이상의 쓰레드를 포함)

- **멀티 쓰레드의 장단점**
  - 두 가지 이상의 작업을 동시에 실행할 수 있어 자원을 효율적으로 이용 가능. 하지만 dead lock 및 동기화에 대한 철저한 검증이 필요

- **동기화(Synchronized)**
  - 멀티 쓰레드 사용 시 공유 자원의 동시 접근을 제어, 자원의 유실 방지

<br>

- 예외 클래스

    <img src="..\post_img\JavaException.png" alt="img" style="zoom: 80%;" />

- **ArrayList<E,>**

  - 가변 크기 배열을 구현한 클래스

  - ArrayList에 삽입 가능한 것 

    - 객체, null 
    - 기본 타입은 박싱/언박싱으로 Wrapper 객체로 만들어 저장 

  - ArrayList에 객체 삽입/삭제 

    - 리스트의 맨 뒤에 객체 추가 
    - 리스트의 중간에 객체 삽입 
    - 임의의 위치에 있는 객체 삭제 가능 

  - 벡터와 달리 스레드 동기화 기능 없음 

    - 다수 스레드가 동시에 ArrayList에 접근할 때 동기화되지 않음 
    - 개발자가 스레드 동기화 코드 작성 

  - ```java
    ArrayList<String> = new ArrayList<String>(); 
    ```

    -  add()를 이용하여 요소를 삽입, get()을 이용하여 요소를 검색
    - Vector와 달리 capacity() 메소드 없음 

- 컬렉션의 순차 검색을 위한 **Iterator**

  - Vector<E>, ArrayList<E>, LinkedList<E>가 상속받는 인터페이스
    - 리스트구조의 컬렉션에서 요소의 순차검색을 위한 메소드 포함
  - iterator() 메소드: Iterator 객체반환
    - Iterator 객체를 이용하여 인덱스 없이 순차적 검색 가능

-  **HashMap<K,V>**

  - 키와 값의 쌍으로 구성되는 요소를 다루는 컬렉션

    - K는 키로 사용할 요소의 타입, V는 값으로 사용할 요소의 타입 지정 (키와 값이 한 쌍으로 삽입)
    - 키는 해시맵에 삽입되는 위치 결정에 사용
    - 값을 검색하기 위해서는 반드시 키 이용 

  - 삽입, 삭제, 검색이 빠른 특징

    - 요소삽입: put() 메소드 / 요소검색: get() 메소드

  - ```java
    HashMap<String, String> map = new HashMap<String, String>(); 
    ```

- **inkedList<E,>**

  - List 인터페이스를 구현한 컬렉션 클래스

  - Vector, ArrayList클래스와 매우 유사하게 작동

  - 요소 객체들은 양방향으로 연결되어 관리

  - 요소 객체는 맨 앞, 맨 뒤에 추가 가능

  - 요소 객체는 인덱스를 이용하여 중간에 삽입 가능

  - 맨 앞이나 맨 뒤에 요소를 추가하거나 삭제 할 수 있어 스택이나 큐로 사용 가능 

  - ```java
    LinkedList<String> l = new LinkedList<String>(); 
    ```

<br>

- **Java Collection의 대표 인터페이스**
  - List : 순서가 있는 데이터의 집합, 데이터 중복 허용 O (ArrayList, LinkedList, Stack, Vector)

  - Set : 순서를 유지하지 않는 데이터의 집합, 데이터 중복 허용 X (HashSet, TreeSet)

  - Map : 키와 값의 쌍으로 이루어진 데이터의 집합, 순서 유지 X, 키 중복 허용 X, 값 중복 허용 O (HashMap, TreeMap, HashTable, Properties)


<br>

- **객체의 직렬화(Serialize)**
  - 객체를 직렬화하여 전송 가능한 형태로 만드는 것
  - 객체들의 데이터를 연속적인 데이터로 변형하여 Stream을 통해 데이터를 읽도록 해줌
  - 객체를 String 형태의 데이터로 만들기 위해 연속적인 데이터(serial)로 변환 필요
    - String 형태의 데이터를 읽어 객체로 만드는 것을 역직렬화 

<br>

- **NIO**
  - 기존 자바IO의 단점을 보완한 New IO(NIO) 패키지, Nonblocking IO를 지원
  - Buffer 클래스를 도입하여 기존에 단순배열로만 처리해야 했던 많은 부분들을 좀 더 효율적이고 편리하게 다룰 수 있도록 지원
  - 기존 단방향 스트림에서 Channel을 도입하여 읽기, 쓰기, 읽고쓰기 등 세가지 형태의 작업 방식을 지원
  - 단 한 개의 쓰레드만으로 수천에서 수만명의 동시 사용자를 처리할 수 있는 서버 생성 가능

<Br>

- **Call by Reference** : 변수의 주소값을 매개변수로 전달, 메서드 내의 처리 결과가 메서드 밖의 변수에 영향

- **Call by Value** : 변수의 값을 복사하여 매개변수로 전달, 메서드 내의 처리 결과가 메서드 밖의 변수가 영향 X

<br>

- **Framework**
  - 특정 형태의 소프트웨어 문제를 해결하기 위해 상호 협력하는 클래스프레임과 인터페이스 프레임의 집합
  - 특정 틀을 만들어놓고 거기에 살을 붙이며 프로그램을 만드는 형식으로 작업 시간을 줄여주는 것이 특징
  - 특징
    - 개발자들이 가져야할 가이드 라인을 가짐
    - 개발할 수 있는 범위가 정해져 있음
    - 개발자를 위한 다양한 도구를이 지원
  - 장/단점
    - 장점 : 개발 시간을 줄이고 오류로부터 자유로울 수 있음
    - 단점 : 프레임워크에 너무 의존하면 개발 능력이 저하되어 프레임워크 없이 개발하는 것이 불가능해짐

<br>

- **Garbage Collection**
  - 시스템에서 더이상 사용하지 않는 동적 할당된 메모리 블럭을 찾아 자동으로 다시 사용 가능한 자원으로 회수하는 것

<br>

- **JVM(Java Virtual Machine) (=자바 가상 머신)**
  - 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것
  - JAVA와 OS사이에서 중개자 역할을 수행하여 JAVA가 OS에 구애받지 않고 재사용 가능하게 해줌
  - 한정된 메모리를 효율적으로 사용하여 최고의 성능을 내기 위함

<br>

# WEB

- **MVC (Model-View-Controller) 패턴** 
  - 서로 분리되어 각자의 역할에 집중, 유지보수성, 애플리케이션의 확장성, 효율성 향상, 중복코딩이라는 문제점 해결
  - 사용자가 controller를 조작하면 controller는 model을 통해서 데이터를 가져오고 그 정보를 바탕으로 시각적인 표현을 담당하는 View를 제어해서 사용자에게 전달
  - Controller에 다수의 Model과 View가 복잡하게 연결되어 있는 상황 -> 너무 복잡하고 비대해져서, 새 기능을 추가할 때마다 크고 작은 문제점을 가지고 소드 분석이나 테스트도 어려워짐
    - Model : 애플리케이션이 무엇을 "할 것"인지 정의
    - View : 화면에 무엇을 "보여"줄지
    - Controller : 모델이 어떻게 "처리"할지

<br>

- **Servlet** : Container가 이해할 수 있게 구성된 순수 자바 코드로만 이루어진 것 (HTML in JAVA)

- **JSP(Java Server Page)** : html기반에 JAVA코드를 블록화하여 삽입한 것 (JAVA in HTML)

<br>

- **Java Spring Framework**
  - DI(객체의 의존성)를 이용하여 JAVA 어플리케이션을 만들 수 있는 프레임워크, 추가적으로 웹 MVC 모듈을 제공하여 동적인 웹을 효과적으로 만들 수 있도록 여러 가지 서비스를 제공하며 

<br>

- **java REST**
  - 확장성 생성 언어(XML) 파일로 된 웹 페이지를 읽어 원하는 정보를 수집하는 기능 
  - 별도의 전송계층 없이 웹의 자원을 전송하기 위한 인터페이스

<br>

- **CI (Continuous Integration)**
  - 지속적인 통합 -> 개발과 동시에 통합을 진행함으로써 SW의 품질을 향상

<br>

- **DI (Dependency Injection)**
  - 의존성 주입 -> 설정 파일을 통해 객체간의 의존관계를 설정하므로써 외부 Assembler가 객체간의 의존 관계를 정의
  - 객체를 직접 생성하지 않고 외부에서 생성한 후 주입

<br>

- **AOP (Aspect Oriented Programming)**
  - 다양한 곳에서 자주 사용되는 공통 관심요소를 단일 기능으로 뽑아내어 코드의 중복을 줄이고, 관리의 효율성을 높이는 것을 목적
    - ex) 로깅(시스템 상태/작동 정보를 시간 경과에 따라 기록하는 것), 로그인

<br>

- **Get 방식**

  - Client에서 Server로 데이터 전송 시, 주소 뒤에 '이름'과 '값'이 결합된 스트링 형태로 전달
  - 주소창에 쿼리가 보여지므로 보안성이 떨어짐
  - Post방식보다 상대적으로 전송 속도가 빠름
  - 전송 데이터의 한계

- **Post 방식**

  - Server로 보내기 전 인코딩하고, 전송 후 서버에서는 다시 디코딩 작업을 수행
  - 주소창에 전송하는 데이터 정보가 노출되지 않아 Get 방식에 비해 보안성이 높음

   \- Get방식보다 느림

   \- 일정 크기 이상의 데이터를 보내야 할 때 사용

- **Get 방식, Post 방식의 차이점**

  - Get은 주로 웹 브라우저가 웹 서버에 데이터를 요청할 때 사용
  - Post는 웹 브라우저가 웹 서버에 데이터를 전달하기 위해 사용
  - Get을 사용하면 웹 브라우저에서 웹 서버로 전달되는 데이터가 인코딩되어 URL에 붙음
  - Post는 전달되는 데이터가 보아지 않음
  - Get은 전달되는 데이터가 255개의 문자를 초과하는 문제 발생
  - 웹 서버에 많은 데이터를 전달하기 위해 Post 방식을 사용하는 것이 바람직

<br>

- **Session**
  - 특정 웹사이트에서 사용자가 머무르는 기간 또는 한 명의 사용자의 한 번 방문을 의미
  - Session 관련 데이터는 Server에 저장
  - 웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제 시 사라짐
  - Cookie에 비해 높은 보안성

- **Cookie**
  - 사용자의 정보를 유지할 수 없다는 HTTP의 한계를 극복
  - 웹 사이트의 방문 기록을 남겨 사용자와 웹 사이트 사이를 매개해 주는 정보
  - 사용자가 특정 웹 서버에 접속할 때, 생성되는 정보를 담은 임시 파일
  - Client PC에 저장되는 정보이므로 다른 사용자에 의해 임의로 변경이 가능(정보 유출, 낮은 보안성)

<br>

- **AngularJS**
  - 자바스크립트 기반의 오픈 소스 프론트엔드 웹 애플리케이션 프레임워크의 하나
  - 애플리케이션 개발 중에 마주치는 여러 문제들을 해결하기 위해 개발

<br>

- **AngularJS Directive**
  - HTML 태그에 고유한 속성을 추가하고, 태그를 작성하여 HTML 안에 특수한 기능을 할당
  - 이 디렉티브는 AngularJS에 제공되어 있을 뿐 아니라 직접 만들 수 있음, 자신만의 태그를 추가해 나갈 수 있음

<br>

# S/W engineering

### **소프트웨어 생명 주기 모형**

- **폭포수 모형(Waterfall Model)**
  - 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하며 이전 단계로 넘아갈 수 없는 방식
  - 고전적 생명주기, 선형 순차적 모형, 다음 단계 수행을 위해 각 단계가 끝난 후 명확한 결과물 필요
  - 타당성 검토 -> 계획 -> 요구 분석 -> 설계 -> 구현(코딩) -> 시험(검사) -> 유지보수
  - 장점
    - 모형의 적용 경험과 성공 사례가 많음
    - 단계별 정의가 분명하고, 전체 공조의 이해가 용이
    - 단계별 산출물이 정확하여 개발 공정의 기준점을 잘 제시
  - 단점
    - 개발 중 발생하는 새로운 요구나 경험을 반영하기 어려움, 처음부터 사용자들이 모든 요구사항들을 명확하게 제시할 필요가 있음
    - 단계별로 오류 없이 다음 단계로 진행해야 하지만 현실적으로는 오류 없이 진행하기가 어려움
- **프로토타입 모형(Prototype Model)**
  - 사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본제품을 만들어 최종 결과물을 예측하는 모형
  - 시제품은 사용자와 시스템 사이의 인터페이스 중점을 두어 개발
  - 폭포수 모형의 단점을 보완(개발 완료 시점에 발견되는 오류)
  - 프로토타입은 요구 분석 단계에서 사용 프로토타입 평가가 끝나고 개발이 승인되면 다른 모형을 이용하여 본격적인 개발이 이루어짐
    - 요구 분석 : (요구 수집 - 빠른 설계 - 프로토타입 구축 - 고객 평가 - 프로토타입 조정 - 구현)
  - 타당성 검토 -> 계획 -> 요구 분석 -> 설계 -> 구현(코딩) -> 시험(검사) -> 유지보수
  - 장점
    - 요구사항을 충실히 반영하며, 요구사항 변경이 용이
    - 최종 결과물 완성 전에 의뢰자가 최종 결과물 일부 또는 모형을 볼 수 있음
    - 의뢰자나 개발자 모두에게 공동의 참조 모델을 제공
  - 단점
    - 프로토타입의 경우 실제 소프트웨어와 차이가 발생할 수 있어 사용자에게 혼란을 줄 수 있음
    - 단기간에 제작해야하므로 비효율적인 언어나 알고리즘을 사용할 수 있음

### 프로젝트 일정 계획

- WES(Work Breakdown Structure, 업무 분류 구조) 

  - 개발 프로젝트를 여러 개의 작은 관리 단위(소작업)으로 분할하여 계층적으로 기술한 업무 구조

- PERT/CPM 개요

  - PERT/CPM 네트워크는 프로젝트의 지연을 방지하고 계획대로 진행되게 하기 위한 일정을 계획
  - 대단위 계획의 조직적인 추진을 위해 자원의 제약하에 비용을 적게 사용하면서 초단시간 내 계획 완성을 위한 프로젝트 일정 방법

  -  프로젝트 개발 기간을 결정하는 임계 경로(CP: Critical Path)를 제공

- PERT(Program Evaluation and Review Technique, 프로그램 평가 및 검토 기술)

  - 프로젝트에 필요한 전체 작업의 상호 관계를 표시하는 네트워크
  - 각 작업별로 낙관적인 경우, 가능성이 있는 경우, 비관적인 경우로 나누어 각 단계별 종료 시기를 결정하는 방법
  - 결정 경로, 작업에 대한 경계 시간, 작업 간의 상호 관련성 등을 알 수 있음
  - 노드는 작업, 간선(화살표)는 낙관치, 기대치, 비관치를 표시

- CPM(Critical Path Method, 임계 경로 기법)

  - 프로젝트 완성에 필요한 작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 방법
  - 노드는 각 작업 이름과 소요 기간, 박스 노드는 이정표, 박스 노드 위는 예상 완료 시간

- 간트 차트(Gantt Chart)

  - 프로젝트의 각 작업들이 언제 시작하고 언제 종료되는지에 대한 작업 일정을 막대 도표를 이용하여 표시하는 프로젝트 일정표, 시간선(Time-Line) 차트라고도 함
  - 이정표(작업의 기간), 작업 일정, 작업 기간, 산출물로 구성

### 소프트웨어 품질 보증

- 품질 표준(목표)

  - 명확하게 정의된 소프트웨어의 특성, 소프트웨어의 품질을 평가하는 기준 항목으로  사용

  - |              구분              |    품질 표준     |                             의미                             |
    | :----------------------------: | :--------------: | :----------------------------------------------------------: |
    |   소프트웨어<br />운영 특성    |      정확성      |             사용자의 요구 기능을 충족시키는 정도             |
    |                                |      신뢰성      |     정확하고 일관된 결과를 얻기 위해 오류 없이 수행 정도     |
    |                                |      효율성      |      요구 기능을 수행하기 위한 필요한 자원의 소요 정도       |
    |                                |      무결성      |      허용되지 않는 사용이나 자료의 변경을 제어하는 정도      |
    |                                | 사용<br />용이성 |    사용에 필요한 노력을 최소화, 쉽게 사용할 수 있는 정도     |
    | 소프트웨어<br />변경 수용 능력 |    유지보수성    |     변경 및 오류 사항의 교정에 대한 노력 최소화하는 정도     |
    |                                |      유연성      |       소프트웨어를 얼만큼 쉽게 수정할 수 있는가의 정도       |
    |                                |    시험 역량     | 의도된 기능이 수행되도록 보장하기 위해 프로그램을 시험할 수 있는 정도 |
    |   소프트웨어<br />적응 능력    |      이식성      | 다양한 하드웨어 환경에서도 운용 가능하도록 쉽게 수정될 수 있는 정도 |
    |                                |     재사용성     | 전체나 일부 소프트웨어를 다른 목적으로 사용할 수 있는가 하는 정도 |
    |                                |   상호 운용성    |         다른 소프트웨어와 정보를 교환할 수 있는 정도         |