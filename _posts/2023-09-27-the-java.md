---
layout: post
title: The Java
summary: java8
categories: JAVA
featured-img: the-java
---

# The Java

## Java 8

**Java 8**
- LTS(Long-Term-Support) 버전
- 출시일: 2014년 3월
- 주요 기능
  - 람다 표현식, 메소드 레퍼런스, 스트림 API, Optional<T> ...
- [Oracle JDK](https://www.oracle.com/java/technologies/downloads/#java21)
- Open JDK: Oracle, AdoptOpenJDK, Amazon Corretto, Azul Zulu
- 참고.
  - [Java Development Kit 8 Update Release Notes](https://www.oracle.com/java/technologies/javase/8u-relnotes.html)
  - [Which versions of Java do you regularly use?](https://www.jetbrains.com/lp/devecosystem-2022/java/)
  - [Oracle Java SE Support Roadmap](https://www.oracle.com/java/technologies/java-se-support-roadmap.html)
  - [Java version history](https://en.wikipedia.org/wiki/Java_version_history)
  - [What Does Long-Term Support Mean for OpenJDK?](https://www.javacodegeeks.com/2019/07/long-term-support-mean-openjdk.html)

.

**LTS(Long-Term-Support)**
- 비-LTS
  - 배포 주기: `6개월`
  - 지원 기간: 배포 이후 `6개월`(다음 버전이 나오면 지원 종료)
- LTS
  - 배포 주기: `3년`(매 6번째 배포판이 LTS)
  - 지원 기간: `5년이상`(JDK 제공 밴더와 이용하는 서비스에 따라 차이)
  - 실제 서비스 운영 환경에서는 LTS 버전 권장
- 매년 3월과 9월에 새 버전 배포

## Functional Interface & Lambda

함수형 인터페이스(Functional Interface)
```java
@FunctionalInterface
public interface RunSomething {
    void doIt();
}
```
- 추상 메소드를 딱 하나만 가지고 있는 인터페이스
- SAM(Single Abstract Method) 인터페이스
- @FuncationInterface 애노테이션을 가지고 있는 인터페이스

.

람다 표현식(Lambda Expressions)
```java
RunSomething runSomething = () -> System.out.println("Hello");
RunSomething2 runSomething2 = number -> number + 10;

runSomething.doIt();
runSomething2.doIt();
```
- 간결한 코드
- 함수형 인터페이스의 인스턴스를 만드는 방법으로 사용 가능
- 메소드 매개변수, 리턴 타입, 변수로 만들어 사용 가능

.

**자바에서 함수형 프로그래밍**
- 함수를 First class object로 사용 가능
- 순수 함수(Pure function)
  - 사이드 이팩트 없음(함수 밖에 있는 값을 변경하지 않음)
  - 상태가 없음(함수 밖에 있는 값을 사용하지 않음)
- 고차 함수(Higher-Order Function)
  - 함수가 함수를 매개변수로 받을 수 있고, 함수 리턴 가능
- 불변성

.

**Java 기본 제공 함수형 인터페이스**
- [java.lang.funcation package](https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html)

`Function<T, R>`
- T 타입을 받아서 R 타입을 리턴하는 함수 인터페이스
```java
private final Function<Integer, Integer> plus10 = (num) -> num + 10;
  private final Function<Integer, Integer> multiply2 = (num) -> num * 2;

  @Test
  void apply() throws Exception {
      /**
       * R apply(T t)
       */
      Assertions.assertEquals(11, plus10.apply(1));
  }

  @Test
  void compose() throws Exception {
      /**
       * Function<V, R> compose(Function<? super V, ? extends T> before)
       * multiply2 실행 이후 plus10 실행
       */
      Function<Integer, Integer> multiply2AndPlus10 = plus10.compose(multiply2);
      Assertions.assertEquals(14, multiply2AndPlus10.apply(2)); // (num * 2) + 10
  }

  @Test
  void andThen() throws Exception {
      /**
       * Function<T, V> andThen(Function<? super R, ? extends V> after)
       * plus10 실행 이후 multiply2 실행
       */
      Function<Integer, Integer> plus10AndMultiply2 = plus10.andThen(multiply2);
      Assertions.assertEquals(24, plus10AndMultiply2.apply(2)); // (num + 10) * 2
  }
```

`BiFunction<T, U, R>`
- 두 개의 값(T, U)를 받아서 R 타입을 리턴하는 함수 인터페이스
- R apply(T t, U u)
```java
@Test
void apply() throws Exception {
    /**
     * R apply(T t, U u);
     */
    BiFunction<Integer, Integer, Integer> add = (num1, num2) ->  num1 + num2;
    BiFunction<Integer, Integer, Integer> minus = (num1, num2) -> num1 - num2;
    BiFunction<Integer, Integer, Integer> multiple = (num1, num2) -> num1 * num2;

    Assertions.assertEquals(15, add.apply(10, 5));
    Assertions.assertEquals(5, minus.apply(10, 5));
    Assertions.assertEquals(50, multiple.apply(10, 5));
}
```

`Consumer<T>`
- T 타입을 받아서 아무값도 리턴하지 않는 함수 인터페이스
```java
@Test
void accept() throws Exception {
    /**
     * void accept(T t);
     */
    Consumer<Integer> printT = System.out::println;
    printT.accept(10); // 10
}

@Test
void andThen() throws Exception {
    /**
     * Consumer<T> andThen(Consumer<? super T> after)
     */
    Consumer<String> printJava = s -> System.out.println(s + "Java ");
    Consumer<String> printWorld = s -> System.out.println(s + "World ");;
    printJava.andThen(printWorld).accept("Hello"); // HelloJava -> HelloWorld
}
```

`Supplier<T>`
- T 타입의 값을 제공하는 함수 인터페이스
```java
@Test
void get() throws Exception {
    /**
     * T get()
     */
    Supplier<Integer> get10 = () -> 10;
    Assertions.assertEquals(10, get10.get());
}
```

`Predicate<T>`
- T 타입을 받아서 boolean을 리턴하는 함수 인터페이스
- 함수 조합용 메소드
```java
private final Predicate<Integer> isEven = i -> i % 2 == 0;
private final Predicate<Integer> under10 = i -> i < 10;

@Test
void test() throws Exception {
    /**
     * boolean test(T t);
     */
    Predicate<String> startsWithHello = s -> s.startsWith("hello");

    Assertions.assertTrue(startsWithHello.test("hello Aaron"));
    Assertions.assertTrue(isEven.test(8));
}

@Test
void and() throws Exception {
    /**
     * Predicate<T> and(Predicate<? super T> other)
     */
    Assertions.assertTrue(isEven.and(under10).test(4));
    Assertions.assertFalse(isEven.and(under10).test(12));
}

@Test
void or() throws Exception {
    /**
     * Predicate<T> or(Predicate<? super T> other)
     */
    Assertions.assertTrue(isEven.or(under10).test(4));
    Assertions.assertTrue(isEven.or(under10).test(12));
    Assertions.assertTrue(isEven.or(under10).test(7));
}

@Test
void negate() throws Exception {
    /**
     * Predicate<T> negate()
     */
    Assertions.assertTrue(isEven.negate().test(5));
    Assertions.assertTrue(under10.negate().test(17));
    Assertions.assertFalse(isEven.negate().test(4));
    Assertions.assertFalse(under10.negate().test(5));
}
```

`UnaryOperator<T>`
- Function<T, R>의 특수한 형태(Function 상속)
- 입력값 하나를 받아서 동일한 타입을 리턴하는 함수 인터페이스
```java
private final UnaryOperator<Integer> plus10 = (num) -> num + 10;
private final UnaryOperator<Integer> multiply2 = (num) -> num * 2;

@Test
void test() throws Exception {
    Assertions.assertEquals(11, plus10.apply(1));
    Assertions.assertEquals(14, plus10.compose(multiply2).apply(2)); // (num * 2) + 10
    Assertions.assertEquals(24, plus10.andThen(multiply2).apply(2)); // (num + 10) * 2
}
```

`BinaryOperator<T>`
- BiFunction<T, U, R>의 특수한 형태
- 동일한 타입의 입렵값 두 개를 받아 리턴하는 함수 인터페이스
```java
@Test
void apply() throws Exception {
    /**
     * R apply(T t, U u);
     */
    BinaryOperator<Integer> add = (num1, num2) ->  num1 + num2;
    BinaryOperator<Integer> minus = (num1, num2) -> num1 - num2;
    BinaryOperator<Integer> multiple = (num1, num2) -> num1 * num2;

    Assertions.assertEquals(15, add.apply(10, 5));
    Assertions.assertEquals(5, minus.apply(10, 5));
    Assertions.assertEquals(50, multiple.apply(10, 5));
}
```