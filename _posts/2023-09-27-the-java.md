---
layout: post
title: The Java
summary: java8
categories: JAVA
featured-img: the-java
---

# The Java

## Java 8

**Java 8**
- LTS(Long-Term-Support) 버전
- 출시일: 2014년 3월
- 주요 기능
  - 람다 표현식, 메소드 레퍼런스, 스트림 API, Optional<T> ...
- [Oracle JDK](https://www.oracle.com/java/technologies/downloads/#java21)
- Open JDK: Oracle, AdoptOpenJDK, Amazon Corretto, Azul Zulu
- 참고.
  - [Java Development Kit 8 Update Release Notes](https://www.oracle.com/java/technologies/javase/8u-relnotes.html)
  - [Which versions of Java do you regularly use?](https://www.jetbrains.com/lp/devecosystem-2022/java/)
  - [Oracle Java SE Support Roadmap](https://www.oracle.com/java/technologies/java-se-support-roadmap.html)
  - [Java version history](https://en.wikipedia.org/wiki/Java_version_history)
  - [What Does Long-Term Support Mean for OpenJDK?](https://www.javacodegeeks.com/2019/07/long-term-support-mean-openjdk.html)

.

**LTS(Long-Term-Support)**
- 비-LTS
  - 배포 주기: `6개월`
  - 지원 기간: 배포 이후 `6개월`(다음 버전이 나오면 지원 종료)
- LTS
  - 배포 주기: `3년`(매 6번째 배포판이 LTS)
  - 지원 기간: `5년이상`(JDK 제공 밴더와 이용하는 서비스에 따라 차이)
  - 실제 서비스 운영 환경에서는 LTS 버전 권장
- 매년 3월과 9월에 새 버전 배포

## Functional Interface & Lambda

함수형 인터페이스(Functional Interface)
```java
@FunctionalInterface
public interface RunSomething {
    void doIt();
}
```
- 추상 메소드를 딱 하나만 가지고 있는 인터페이스
- SAM(Single Abstract Method) 인터페이스
- @FuncationInterface 애노테이션을 가지고 있는 인터페이스

.

람다 표현식(Lambda Expressions)
```java
RunSomething runSomething = () -> System.out.println("Hello");
RunSomething2 runSomething2 = number -> number + 10;

runSomething.doIt();
runSomething2.doIt();
```
- 간결한 코드
- 함수형 인터페이스의 인스턴스를 만드는 방법으로 사용 가능
- 메소드 매개변수, 리턴 타입, 변수로 만들어 사용 가능

.

**자바에서 함수형 프로그래밍**
- 함수를 First class object로 사용 가능
- 순수 함수(Pure function)
  - 사이드 이팩트 없음(함수 밖에 있는 값을 변경하지 않음)
  - 상태가 없음(함수 밖에 있는 값을 사용하지 않음)
- 고차 함수(Higher-Order Function)
  - 함수가 함수를 매개변수로 받을 수 있고, 함수 리턴 가능
- 불변성

### Functional Interface

**Java 기본 제공 함수형 인터페이스**
- [java.lang.funcation package](https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html)

`Function<T, R>`
- T 타입을 받아서 R 타입을 리턴하는 함수 인터페이스
```java
private final Function<Integer, Integer> plus10 = (num) -> num + 10;
  private final Function<Integer, Integer> multiply2 = (num) -> num * 2;

  @Test
  void apply() throws Exception {
      /**
       * R apply(T t)
       */
      Assertions.assertEquals(11, plus10.apply(1));
  }

  @Test
  void compose() throws Exception {
      /**
       * Function<V, R> compose(Function<? super V, ? extends T> before)
       * multiply2 실행 이후 plus10 실행
       */
      Function<Integer, Integer> multiply2AndPlus10 = plus10.compose(multiply2);
      Assertions.assertEquals(14, multiply2AndPlus10.apply(2)); // (num * 2) + 10
  }

  @Test
  void andThen() throws Exception {
      /**
       * Function<T, V> andThen(Function<? super R, ? extends V> after)
       * plus10 실행 이후 multiply2 실행
       */
      Function<Integer, Integer> plus10AndMultiply2 = plus10.andThen(multiply2);
      Assertions.assertEquals(24, plus10AndMultiply2.apply(2)); // (num + 10) * 2
  }
```

`BiFunction<T, U, R>`
- 두 개의 값(T, U)를 받아서 R 타입을 리턴하는 함수 인터페이스
- R apply(T t, U u)
```java
@Test
void apply() throws Exception {
    /**
     * R apply(T t, U u);
     */
    BiFunction<Integer, Integer, Integer> add = (num1, num2) ->  num1 + num2;
    BiFunction<Integer, Integer, Integer> minus = (num1, num2) -> num1 - num2;
    BiFunction<Integer, Integer, Integer> multiple = (num1, num2) -> num1 * num2;

    Assertions.assertEquals(15, add.apply(10, 5));
    Assertions.assertEquals(5, minus.apply(10, 5));
    Assertions.assertEquals(50, multiple.apply(10, 5));
}
```

`Consumer<T>`
- T 타입을 받아서 아무값도 리턴하지 않는 함수 인터페이스
```java
@Test
void accept() throws Exception {
    /**
     * void accept(T t);
     */
    Consumer<Integer> printT = System.out::println;
    printT.accept(10); // 10
}

@Test
void andThen() throws Exception {
    /**
     * Consumer<T> andThen(Consumer<? super T> after)
     */
    Consumer<String> printJava = s -> System.out.println(s + "Java ");
    Consumer<String> printWorld = s -> System.out.println(s + "World ");;
    printJava.andThen(printWorld).accept("Hello"); // HelloJava -> HelloWorld
}
```

`Supplier<T>`
- T 타입의 값을 제공하는 함수 인터페이스
```java
@Test
void get() throws Exception {
    /**
     * T get()
     */
    Supplier<Integer> get10 = () -> 10;
    Assertions.assertEquals(10, get10.get());
}
```

`Predicate<T>`
- T 타입을 받아서 boolean을 리턴하는 함수 인터페이스
- 함수 조합용 메소드
```java
private final Predicate<Integer> isEven = i -> i % 2 == 0;
private final Predicate<Integer> under10 = i -> i < 10;

@Test
void test() throws Exception {
    /**
     * boolean test(T t);
     */
    Predicate<String> startsWithHello = s -> s.startsWith("hello");

    Assertions.assertTrue(startsWithHello.test("hello Aaron"));
    Assertions.assertTrue(isEven.test(8));
}

@Test
void and() throws Exception {
    /**
     * Predicate<T> and(Predicate<? super T> other)
     */
    Assertions.assertTrue(isEven.and(under10).test(4));
    Assertions.assertFalse(isEven.and(under10).test(12));
}

@Test
void or() throws Exception {
    /**
     * Predicate<T> or(Predicate<? super T> other)
     */
    Assertions.assertTrue(isEven.or(under10).test(4));
    Assertions.assertTrue(isEven.or(under10).test(12));
    Assertions.assertTrue(isEven.or(under10).test(7));
}

@Test
void negate() throws Exception {
    /**
     * Predicate<T> negate()
     */
    Assertions.assertTrue(isEven.negate().test(5));
    Assertions.assertTrue(under10.negate().test(17));
    Assertions.assertFalse(isEven.negate().test(4));
    Assertions.assertFalse(under10.negate().test(5));
}
```

`UnaryOperator<T>`
- Function<T, R>의 특수한 형태(Function 상속)
- 입력값 하나를 받아서 동일한 타입을 리턴하는 함수 인터페이스
```java
private final UnaryOperator<Integer> plus10 = (num) -> num + 10;
private final UnaryOperator<Integer> multiply2 = (num) -> num * 2;

@Test
void test() throws Exception {
    Assertions.assertEquals(11, plus10.apply(1));
    Assertions.assertEquals(14, plus10.compose(multiply2).apply(2)); // (num * 2) + 10
    Assertions.assertEquals(24, plus10.andThen(multiply2).apply(2)); // (num + 10) * 2
}
```

`BinaryOperator<T>`
- BiFunction<T, U, R>의 특수한 형태
- 동일한 타입의 입렵값 두 개를 받아 리턴하는 함수 인터페이스
```java
@Test
void apply() throws Exception {
    /**
     * R apply(T t, U u);
     */
    BinaryOperator<Integer> add = (num1, num2) ->  num1 + num2;
    BinaryOperator<Integer> minus = (num1, num2) -> num1 - num2;
    BinaryOperator<Integer> multiple = (num1, num2) -> num1 * num2;

    Assertions.assertEquals(15, add.apply(10, 5));
    Assertions.assertEquals(5, minus.apply(10, 5));
    Assertions.assertEquals(50, multiple.apply(10, 5));
}
```

### Lambda

[Lambda Expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)

`(인자 리스트) -> {바디}`

.

인자 리스트
- 인자 없음: ()
- 인자가 한 개: (one) 또는 one
- 인자가 여러 개: (one, two)
- 인자의 타입은 생략 가능(컴파일러가 추론하지만 명시도 가능)

.

바디
- 화살표 오른쪽에 함수 본문 정의
- 여러 줄인 경우 {} 사용
- 한 줄인 경우 바디, return 생략 가능

.

변수 캡처(Variable Capture)
- 로컬 변수 캡처
  - final, effective final 인 경우에만 참조 가능
  - 그렇지 않을 경우, concurrency 문제가 발생할 수 있어서 컴파일러가 방지
- effective final
  - 자바 8부터 지원하는 기능
  - final 키워드를 사용하지 않지만, 변경이 없는 변수를 익명 클래스 구현체, 람다에서 참조 가능
- 람다는 익명 클래스 구현체와 달리 [Shadowing](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing)하지 않음
  - 익명 클래스는 새로운 스콥을 만들지만, 람다는 람다를 감싸고 있는 스콥과 같음
  - 람다를 감싼 스콥에 있는 동일한 이름의 변수 정의 불가

### Method Reference

[Method References](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html) 를 사용해서 메소드, 생성자 호출를 매우 간결하게 표현 가능

```java
@Test
void static_method_reference() throws Exception {
    // static method reference(Type::static-method)
    UnaryOperator<String> hi = Greeting::hi;
    assertEquals("hi aaron", hi.apply("aaron"));
}

@Test
void random_object_instance_method_reference() throws Exception {
    String[] names = {"ccc", "aaa", "bbb"};
    // random object instance method reference(Type::instance-method)
    Arrays.sort(names, String::compareToIgnoreCase);
    assertEquals("[aaa, bbb, ccc]", Arrays.toString(names));
}

@Test
void no_arg_constructor_reference() throws Exception {
    // no arg constructor reference(Type::new)
    Supplier<Greeting> greetingSupplier = Greeting::new;
    Greeting greeting = greetingSupplier.get();
    // specific object instance method reference(Object-reference::instance-method)
    UnaryOperator<String> hello = greeting::hello;

    assertEquals("Hello Aaron", hello.apply("Aaron"));
}

@Test
void AllArgsConstructor() throws Exception {
    // arg constructor reference(Type::new)
    Function<String, Greeting> greetingFunction = Greeting::new;
    Greeting greeting = greetingFunction.apply("aaron");
    assertEquals("aaron", greeting.getName());
}

@Getter
@NoArgsConstructor
@AllArgsConstructor
private class Greeting {
    private String name;

    public String hello(String name) {
        return "Hello " + name;
    }

    public static String hi(String name) {
        return "hi " + name;
    }
}
```