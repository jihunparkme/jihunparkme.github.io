---
layout: post
title: C++ from A to Z
summary: everything about C++
categories: Algorithm
featured-img: C++
# mathjax: true
---


# Table of Contents

* [Basic of C++](#Basic-of-C++)
  
  * [입출력](#입출력)
  * [함수의 오버로딩](#함수의-오버로딩)
  * [매개변수의 디폴트 값](#매개변수의-디폴트-값)
  * [인라인 (inline) 함수](#인라인-(inline)-함수)
  * [이름공간(namespace)](#이름공간(namespace))
  * [파일의 분할](#파일의-분할)
  * [using을 이용한 이름공간 명시](#using을-이용한-이름공간-명시)
  * [Const](#Const)
  * [참조자(Reference)](#참조자(Reference))
  
  

## Basic of C++

#### 입출력

- 입출력 수행을 위해 헤더 파일 선언문 #include <iostream.>

- 입력

  - ```C++
    std::cin >> "변수1" >> "변수2";
    ```
    
- 배열기반 문자열 입출력
  
    - ```c++
      char name[100];
      std::cin >> name;
      std::cout << "my name is " << name << ".\n"
      ```
  
    - 
  
- 출력

  - ```c++
    std::cout << "출력대상1" << "출력대상2" << "출력대상3" << std::endl; 
    ```

#### 함수의 오버로딩

- (Function Overloading)

- 매개변수의 선언형태가 다르다면, 동일한 이름의 함수정의를 허용

- 단, 매개변수의 자료형 또는 개수가 달라야 함

  - ```c++
    void Func(int n) { ... }
    int Func(int n) { ... }
    // 위 두 함수는 오버로딩 불가
    ```

#### 매개변수의 디폴트 값

- (Default Value)

- 매개변수에 디폴트 값이 설정되어 있으면, 선언된 매개변수의 수보다 적은 수의 인자전달이 가능

- 그리고 전달되는 인자는 왼쪽에서부터 채워져 나가고, 부족분은 디폴트 값으로 채워짐

- ```c++
  int Func(int num1, int num2, int num3=30) { ... }  // O
  int WrongFunc(int num1=10, int num2, int num3) { ... }  // X
  ```

#### 인라인 (inline) 함수

- C언어의 매크로 함수와 유사하지만 일반 함수처럼 정의가 가능

- ```c++
  inline int SQUARE(int x)
  {
      return x*x;
  }
  
  int main(void)
  {
      std::cout<<SQUARE(%)<<std::endl;
      return 0;
  }
  ```

- 하지만 자료혀엥 의존적인 함수가 되어 데이터 손실이 발생

  - 이 부분은 template 으로 해결 가능

  - ```c++
    template <typename T>
    inline T SQUARE(T x)
    {
        return x*x;
    }
    ```

#### 이름공간(namespace)

- 특정 영역에 이름을 붙여주기 위한 문법적 요소

- 이름과 매개변수가 동일한 함수라도 이름의 공간을 마련하여 분리하여 사용 가능

- :: 연산자는 범위지정 연산자(scope resolution operator)라고 하며, 이름공간을 지정할 때 사용

- ```c++
  #include <iostream>
  
  namespace BestCom
  {
      void SampleFunc(void)
      {
          std::cout<<"BestCom Function"<<std::endl;
      }
  }
  
  namespace ProgCom
  {
      void SampleFunc(void)
      {
          std::cout<<"ProgCom Function"<<std::endl;
      }
  }
  
  int main(void)
  {
      BestCom::SampleFunc();
      ProgCom::SampleFunc();
      return 0;
  }
  ```

- 이름공간 기반의 함수 선언과 정의의 구분

  - ```c++
    #include <iostream>
    
    namespace BestCom
    {
        void SampleFunc(void)
    }
    
    namespace BestCom
    {
        void PrettyFunc(void)
    }
    
    namespace ProgCom
    {
        void SampleFunc(void)
    }
    
    int main(void)
    {
        BestCom::SampleFunc();
        ProgCom::SampleFunc();
        return 0;
    }
    
    void BestCom::SampleFunc(void)
    {
        std::cout<<"BestCom Function"<<std::endl;
        PrettyFunc();	// 동일 이름공간을 명시할 필요가 없음
    }
    void ProgCom::SampleFunc(void)
    {
        std::cout<<"ProgCom Function"<<std::endl;
    }
    ```

- 이름공간의 중첩

  - ```c++
    namespace Parent
    {
        int num = 2;
        namespace SubOne
        {
            int num = 3;
        }
        namespace SubTwo
        {
            int num = 4;
        }
    }
    
    int main(void)
    {
        std::cout<< Parent::num <<std::endl;
        std::cout<< Parent::SubOne::num <<std::endl;
        std::cout<< Parent::SubTow::num <<std::endl;
        return 0;
    }
    ```

#### 파일의 분할

- 헤더파일 : main 함수를 제외한 나머지 두 함수의 선언을 삽입
- 소스파일 1 : main 함수를 제외한 나머지 두 함수의 정의를 삽입
- 소스파일 2 : main 함수만 삽입

#### using을 이용한 이름공간 명시

- using

- ```c++
  namespace BestCom
  {
      void SampleFunc(void)
      {
          std::cout<<"BestCom Function"<<std::endl;
      }
  }
  ```

  - 여기서 매번 BestCom::SampleFunc 같이 선언하기에 불편함이 있음

    - ```c++
      #include <iostream>
      using BestCom::SampleFunc;
      using std::cin;
      using std::cout;
      using std::endl;
      
      int main(void)
      {
          SampleFunc();
          return 0;
      }
      ```

    - using 선언은 SampleFunc를 이름공간 BestCom에서 찾으라는 일종의 선언

  - 일일이 using 선언을 하는 것도 번거롭다면, 이름공간 std에 선언된 모든 것에 대해 이름공간 지정의 생략을 명령 가능

    - ```C++
      #include <iostream>
      using namespace std;
      
      int main(void)
      {
          ...
          return 0;
      }
      ```

    - 단, 프로그래밍에 조금 편하지만 그만큼 이름충돌이 발생할 확률이 상대적으로 높아짐

    - 상황을 판단하여 적절히 혼용하는 지혜가 필요

- 이름공간이 과도하게 중첩될 경우는 드물지만 상황에 의해서 과도하게 사용되었을 때,

  - ```c++
    namespace ABC=AAA:BBB:CCC;
    ```

  - 위 방법으로 별칭을 줄일 수 있음

- 범위지정 연산자의 또 다른 기능으로 전역변수가 지역변수에 의해 가려진다는 특징을 해결

  - ```c++
    int val = 100; 	// 전역변수
    
    int SampleFunc(void)
    {
        int val = 20;	// 지역변수
        val += 3;		// 지역변수 val의 값 3 증가
        ::val += 7;		// 전역변수 val의 값 7 증가
    }
    ```

#### Const

- ```c++
  const int num=10;		// 변수 num을 상수화
  const int * ptr1 = &val1;		// 포인터 ptr1을 이용하여 val1 값 변경 불가능
  int * const ptr2 = &val2;		// 포인터 ptr2가 상수화 됨
  const int * const ptr3 = &val3;	
                       // 포인터 ptr3가 상수화 되었으며, ptr3를 이용하여 val3 값 변경 불가능
  ```

#### 참조자(Reference)

- 참조자는 자신이 참조하는 변수를 대신할 수 있는 또 하나의 이름 = 별명(별칭)
- 참조자가 메모리 공간에 다른 값이 선언되면 변수도 값이 변경됨(같은 메모리 공간을 사용)

- ```c++
  int num1 = 2020;
  int &num2 = num1;	// num1이라는 이름이 붙어있는 메모리 공간에 num2라는 이름이 하나 더 생김
  ```

  - 이미 선언된 변수의 앞에 이 연산자가 오면 주소 값의 반환을 명령하는 뜻이 되지만, 새로 선언되는 변수의 이름앞에 등장하면, 참조자의 선언을 뜻함

  - ```c++
    int *ptr = &num1;	// 변수 num1의 주소 값을 반환하여 포인터 ptr에 저장
    int &num2 = num1;	// 변수 num1에 대한 참조자 num2를 선언
    ```

- 참조자 수에는 제한이 없으며, 참조자를 대상으로도 참조자를 선언할 수 있음

  - ```c++
    int num1 = 2759;
    int &num2 = num1;
    int &num3 = num1;
    int &num4 = num1;
    ```

- 참조자의 선언 가능 범위

  - 참조자는 무조건 선언과 동시에 변수를 참조하도록 해야 함

  - 참조자는 변수에 대해서만 선언 가능, 선언됨과 동시에 누군가를 참조

  - 상수를 대상으로 참조자를 선언할 수 없음

  - 참조의 대상을 바꾸는 것은 불가능

  - 배열 요소의 참조

    - ```c++
      int arr[3] = {1, 3, 5};
      int &amp;ref1 = arr[0];
      int &amp;ref2 = arr[1];
      int &amp;ref3 = arr[2];
      ```

  - 포인터 변수의 참조

    - ```c++
      int num = 12;
      int *ptr = &num;
      int **dptr = &ptr;
      
      int &ref = num;
      int *(&pref) = prt;
      int **(&dpref) = dptr;
      ```

    - 

