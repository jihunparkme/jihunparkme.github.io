---
layout: post
title: 클래스, 인터페이스, 제네릭
summary: 클래스와 인터페이스, 제네릭
categories: (Book)Effective-JAVA-3/E JAVA
featured-img: EFF_JAVA
# mathjax: true
---

# 4장. 클래스와 인터페이스

클래스와 인터페이스를 사용하기 편하고, 견고하며, 유연하게 만드는 방법

## item 15. 클래스와 멤버의 접근 권한을 최소화하라.

> 프로그램 요소의 접근성은 가능한 한 최소한으로 하자. 
>
> 꼭 필요한 것만 골라 최소한의 public API를 설계하자.
>
> 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 한다.
>
> public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다. 
> 
> public static final 필드가 참조하는 객체가 불변인지 확인하자.

📖

잘 설계된 컴포넌트는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼는지에 달려 있다.

- 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.

**정보 은닉의 장점**

- 시스템 개발 속도를 높인다. -> 여러 컴포넌트를 병렬로 개발
- 시스템 관리 비용을 낮춘다. -> 각 컴포넌트를 빠르게 파악, 디버깅하고, 컴포넌트 교체 부담도 적음
- 성능을 높여주진 않지만 성능 최적화에 도움을 준다. -> 다른 컴포넌트에 영향을 주지 않고 특정 컴포넌트만 최적화
- 소프트웨어 재사용성을 높인다.
- 큰 시스템을 제작하는 난이도를 낮춰준다. -> 개별 컴포넌트 검증 가능

각 요소의 접근성은 그 요소가 선언된 위치와 접근 제한자로 정해진다. 이 접근 제한자를 제대로 활용하는 것이 정보 은닉의 핵심!

- 모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.
- 테스트 코드를 위해 클래스, 인터페이스, 멤버의 접근 범위를 넓히는 것은 적당한 수준까지는 괜찮지만, 공개 API로 만들어서는 안 된다.
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
- public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.
- 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.
  - public 배열을 private으로 만들고 public 불변 리스트를 추가하거나
  - 배열을 private으로 만들고 public으로 그 복사본을 반환하자.

**접근 수준**

- private: 멤버 선언 톱레벨 클래스에서만 접근 가능
- package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능 (default. 단, interface는 public)
- protected: package-private 접근 범위를 포함하고, 멤버를 선언한 클래스의 하위 클래스에서도 접근 가능
- public: 모든 곳에서 접근 가능

<br>

## item 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.

> public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다.
>
> 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다.
>
> 하지만 package-private 클래스나 private 중첩 클래스에서는 종종 (불변이든 가변이든) 필드를 노출하는 편이 나을 때도 있다.

📖

**패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공**함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.

<br>

## item 17. 변경 가능성을 최소화하라.

> 클래스는 꼭 필요한 경우가 아니라면 불변으로 만들자.
> 
> 불변으로 만들 수 없는 클래스라면 변경할 수 있는 부분을 최소한으로 줄여보자.
> 
> 다른 합당한 이유가 없다면 모든 필드는 private final 이어야 한다.

📖

불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.
- 생성된 시점의 상태를 파괴할 때까지 그대로 간직
- 불변 객체는 근본적으로 스레드에 안전하여 따로 동기화할 필요가 없음
- 방어적 복사 불필요(불변 객체를 자유롭게 공유 가능)
- 불변 객체는 자유롭게 공유할 수 있음을 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있음
- 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많음(Map.key, Set.element)
- 불변 객체는 그 자체로 실패 원자성을 제공
- 단점이라면, 값이 다를 경우 반드시 독립된 객체로 만들어야 함

클래스를 불변으로 만들기 위한 규칙

- 객체의 상테를 변경하는 메서드(변경자)를 제공하지 않기
- 클래스를 확장(상속)할 수 없도록 하기
  - final 클래스로 선언하기
  - 생성자를 숨기고 정적 팩터리 제공하기 
    ```java
    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    }
    ```
- 모든 필드를 final로 선언하기
- 모든 필드를 private으로 선언하기
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 하기

[불변 복소수 클래스(Complex.java)](https://github.com/WegraLee/effective-java-3e-source-code/blob/master/src/effectivejava/chapter4/item17/Complex.java)

- 각 메서드에서 인스턴스 자신은 수정하지 않고 새로운 Complex 인스턴스를 만들어 반환하고 있다.
- 정적 팩터리 방식은 다수의 구현 클래스를 활용한 유연성을 제공하고, 객체 캐싱 기능을 추가해 성능을 끌어올릴 수도 있다.

<br>

## item 18. 상속보다는 컴포지션을 사용하라.

> --

📖

<br>

## item 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.

> --

<br>

## item 20. 추상 클래스보다는 인터페이스를 우선하라.

> --

<br>

## item 21. 인터페이스는 구현하는 쪽을 생각해 설계하라.

> --

📖

<br>

## item 22. 인터페이스는 타입을 정의하는 용도로만 사용하라.

> --

📖

<br>

## item 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라.

> --

📖

<br>

## item 24. 멤버 클래스는 되도록 static으로 만들라.

> --

📖

<br>

## item 25. 톱레벨 클래스는 한 파일에 하나만 담으라.

> --

📖

<br>

# 5장. 제네릭

## item 26. 로 타입은 사용하지 말라.

> --

📖

<br>

## item 27. 비검사 경고를 제거하라.

> --

📖

<br>

## item 28. 배열보다는 리스트를 사용하라.

> --

📖

<br>

## item 29. 이왕이면 제네릭 타입으로 만들라.

> --

📖

<br>

## item 30. 이왕이면 제네릭 메서드로 만들라.

> --

📖

<br>

## item 31. 한정적 와일드카드를 사용해 API 유연성을 높이라.

> --

📖

<br>

## item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라.

> --

📖

<br>

## item 33. 타입 안전 이종 컨테이너를 고려하라.

> --

📖


📝🔔🔍

...

**Reference**

- [effective-java-3e-source-code (KOR)](https://github.com/WegraLee/effective-java-3e-source-code)

- [effective-java-3e-source-code (EN)](https://github.com/jbloch/effective-java-3e-source-code)
