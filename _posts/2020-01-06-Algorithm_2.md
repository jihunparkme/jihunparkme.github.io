---
layout: post
title: Algorithm_2
summary: Collect all algorithms
categories: Algorithm
featured-img: algorithms
# mathjax: true
---

# Table of Contents
* [Numerical analysis](#Numerical-analysis)
* [Dynamic Programming](#Dynamic-Programming)
* [Bit- mask](#Bit-mask)
* [Segment Tree](#Segment Tree)
* [Fenwick Tree](#Fenwick-Tree)
* [Graph](#Graph)

# Numerical analysis
- 수치 해석 : 직접 풀기 힘든 수학 문제를 근사적으로 푸는 알고리즘과 이들의 수치적 안정성, 오차의 범위 등으 연구하는 전산학의 한 분야
- 이분법(bisection method) : 가장 유용하게 사용되는 수치 해석 기법
  - 주어진 범위 [lo, hi] 내에서 어떤 함수 f(x)의 값이 0이 되는 지점을 수치적으로 찾아내는 기법
  - 단조 함수(주어진 순서를 보존하는 함수)가 아니고, 답이 여러 개 있는 함수라도 연속이기만 하다면 이분법을 사용해 근을 찾을 수 있음
  - 이분법 사용을 위해 우선 함수의 그래프 상에서 x축 윗부분에 위치한 점 하나와 아랫부분에 위치한 점 하나를 찾아야 함 -> 여기서 (lo, f(lo)) 와 (hi, f(hi)) 가 적당한 후보
  - 이분법은 매 반복마다 [lo, hi] 구간의 크기를 절반으로 줄여 나아감
  	<img src="..\post_img\bisection.png" alt="img" style="zoom: 100%;" />
  
    

# Dynamic Programming
- 동적 계획법
  - 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용함으로써 속도의 향상를 꾀함
  - 두 번 이상 반복 계산되는 부분 문제들의 답을 미리 저장함으로써 속도의 향상을 꾀하는 알고리즘 설계 기법
    - 캐시(cache) : 이미 계산한 값을 저장해 두는 메모리의 장소
    - 중복되는 부분 문제(overlapping subproblems) : 두 번 이상 계산되는 부분 문제
- 메모이제이션(memoization) : 함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법, 메모이제이션은 참조적 투명 함수의 경우에만 적용 가능
  - 참조적 투명 함수(referential transparent function) : 입력이 고정되어 있을 떄, 그 결과가 항상 같은 함수
  
  - 메모이제이션의 패턴
  - ```c++
    #include <iostream>
    
    using namespace std;
    
    int cache[2500][2500];
    
    // a와 b는 [0, 2500) 구간 안의 정수
    int someObsureFunction(int a, int b) {
    	// 기저 사례를 처음으로 처리.ex) 입력 범위를 벗어난 경우
    	if (...) return ...;
    	// (a,b)에 대한 답을 구한 적이 있으면 바로 반환
    	int& rst = cache[a][b];
    	if (rst != -1) return rst;
    	// 답 계산
    	...;
    	return rst;
    }
    
    int main() {
    	ios_base::sync_with_stdio(false);
    	cin.tie(NULL); cout.tie(NULL);
    
    	// memset()함수를 이용하여 cache 배열을 초기화
    	memset(cache, -1, sizeof(cache))
    }
    ```

#### [예제]
[문제 1 : JUMPGAME](https://algospot.com/judge/problem/read/JUMPGAME){: target="_blank"}
- first. 주어진 문제를 (재귀적으로 해결하는) 완전 탐색을 이용하여 해결
  - ```c++
    const int MAX = 100;
    int n, board[MAX][MAX];
    
    bool jump(int y, int x) {
    	// 기저 사례 : 게임판 밖을 벗어난 경우
    	if (y >= n || x >= n) return false;
    	// 기저 사례 : 마지막 칸에 도달한 경우
    	if (y == n - 1 && x == n - 1) return true;
        
    	int jumpSize = board[y][x];
    	return jump(y + jumpSize, x) || jump(y, x + jumpSize);
    }
    ```
- second. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션 적용
  - 완전 탐색 과정에서 중복으로 연산이 되는 부분들이 있는데, 
    이미 해결된 부분 문제들의 결과를 cache에 저장해주면서(메모이제이션 적용) 중복된 연산을 줄여줄 수 있음
  - ```c++
    int n, board[MAX][MAX];
    int cache[MAX][MAX];
    
    bool jump_mmz(int y, int x) {
    	// 기저 사례 : 게임판 밖을 벗어난 경우
    	if (y >= n || x >= n) return 0;
    	// 기저 사례 : 마지막 칸에 도달한 경우
    	if (y == n - 1 && x == n - 1) return 1;
    
    	// 메모이제이션 적용
    	int& rst = cache[y][x];
    	if (rst != -1) return rst;
    	
    	int jumpSize = board[y][x];
    	return rst = jump_mmz(y + jumpSize, x) || jump_mmz(y, x + jumpSize);
    }
    ```

[문제 2 : WILDCARD](https://algospot.com/judge/problem/read/WILDCARD){: target="_blank"}
- ```c++
  #include <iostream>
  #include <string>
  
  int cache[101][101];
  
  string W, S;
  
  bool matchMemoized(int w, int s) {
  	int &ret = cache[w][s];
  	if (ret != -1) return ret;
  
  	// W[w]와 S[s] 비교
  	while (s < S.size() && w < W.size() &&
  		(W[w] == '?' || W[w] == S[s])) {
          // 첫 한 글자씩 떼고 남은 문자열이 서로 대응되는지 재귀 호출로 탐색
  		return ret = matchMemoized(w + 1, s + 1);
  	}
  	
  	// 더 이상 대응할 수 없으면 왜 while문이 끝났는지 확인
  	// 2. 패턴 끝에 도달
  	if (w == W.size()) return ret = (s == S.size());
  
  	// 4. *를 만나서 끝난 경우 : *에 몇 글자를 대응해야 할지
  	if (W[w] == '*') {
  		if (matchMemoized(w + 1, s) ||
  			(s < S.size() && matchMemoized(w, s + 1)))
              // *에 아무 글자도 대응시키지 않을 것인지 || 한 글자를 더 대응시킬 것인지 결정
  			return ret = 1;
  	}
  
  	// 3. 이 외의 경우에는 모두 대응되지 않음
  	return ret = 0;
  }
  ```
  
# Bit-mask
- 비트마스크 : 정수의 이진수 표현을 자료 구조로 쓰는 기법
  - 더 빠른 수행 시간
  - 더 간결한 코드
  - 더 작은 메모리 사용량
  - 연관 배열을 배열로 대체

- 용어 정리
  - 비트(bit) : 0 혹은 1의 값을 가지고,  컴퓨터가 표현하는 모든 자료의 근간
  - 비트 연산자 : 비트마스크를 사용하기 위해서는 정수 변수를 비트별로 조작할 수 있는 비트 연산자를 사용(AND, OR, XOR, NOT, shift)

- 유의 사항
  - 우선순위 : c++,  java에서는 &, |, ^ 등의 비트 연산자의 우선순위는 == 혹은 != 등의 비교 연산자보다 낮음 -> 비트마스크 사용 식에 가급적 괄호는 자세하게 추가하는 습관이 중요
  - 오버플로 : c++에서 1은 부호 있는 32비트 상수로 취급되므로, shift 연산이 32이상 되어버리면 오버플로가 발생. 정수 뒤에 64비트 정수임을 알려주는 접미사 'ull'을 붙여주어야 함. -> 변수의 모든 비트를 다 쓰고 싶을 때는 부호 없는 정수형을 쓰는 것이 좋음

- 집합 구현
  - 공집합 : 상수 0
  - 꽉 찬 집합 : 100000.. 으로 이루어진 이진수에서 1을 빼면 모든 비트가 켜지게 됨
  - ```c++
    // 비트가 모두 켜진 수
    int full = (1<<20) - 1;
    
    // 원소 추가
    toppings |= (1 << p); // p = topping number
    
    // 원소 삭제
    toppings -= (1 << p);  // 이미 토핑 목록에 있을 경우
    toppings &= ~(1 << p);  // 토핑이 없을 경우에도 정상적으로 동작
        
    // 원소 포함 여부 확인
    if(toppings & (1 << p));
        
    // 토글 : 해당 비트가 켜져 있으면 끄고, 꺼져 있으면 켜기
    toppings ^= (1 << p);
    
    // 집합에 포함된 원소의 크기
    // c++ 내장 명령어(32비트 부호 없는 정수) : __popcnt(toppings)
    int bitCount(int x) { 
        if(x == 0) return 0;
        return x % 2 + bitCount(x/2);  // 2^0 + bitCount(x >>1)
    }
    
    // 최소 원소 찾기("이 정수의 이진수 표현에서 끝에 붙은 0이 몇 개인가"에서 착안)
    // c++ 내장 명령어(32비트 부호 없는 정수) : __BitScanForwatd(&index, toppings)
    // 최하위 비트의 번호 대신 해당 비트를 직접 구하기
    int firstTopping = (toppings & -toppings);
    
    // 최소 원소 지우기(어떤 정수가 2의 거듭제곱 값인지 확인할 때 유용)
    topping &= (toppings -1);
    
    // 모든 부분 집한 순회
    for(int subset = pizza; subset; subset = ((subset-1) & pizza)) {
        // subset은 pizza의 부분집합
        // for문은 subset = 0인 시점에 종료, 공집합은 방문하지 않음
    }
    ```

- 참고
  
  - c++ bitset 클래스 ([링크](https://docs.microsoft.com/ko-kr/cpp/standard-library/bitset-class?view=vs-2019){: target="_blank"})

# Segment Tree

- [참고](#https://www.acmicpc.net/blog/view/9){: target="_blank"}
- 구간 트리 : 구간에 대한 질문 대답하기
  - 저장된 자료들을 적절히 전처리해 그들에 대한 질의들을 빠르게 대답할 수 있도록 함
  - 흔히 일차원 배열의 특정 구간에 대한 질문을 빠르게 대답하는데 사용
  - 루드 노드를 배열의 1번 원소로, 노드 i의 왼쪽 자손과 오른쪽 자손을 각각 2 x i 와 2 x i + 1 번 원소로 표현
  - 높이는 log2N의 올림이고, 세그먼트 트리를 만드는데 필요한 배열의 크기는 2^(H+1) - 1
  - 패턴
    ```c++
    long long init(vector<long long> &a, vector<long long> &tree, int node, int start, int end) {
        if (start == end) {
            return tree[node] = a[start];
        } else {
            return tree[node] = init(a, tree, node*2, start, (start+end)/2) + init(a, tree, node*2+1, (start+end)/2+1, end);
        }
    }
    
    void update(vector<long long> &tree, int node, int start, int end, int index, long long diff) {
        if (index < start || index > end) return;
        tree[node] = tree[node] + diff;
        if (start != end) {
            update(tree,node*2, start, (start+end)/2, index, diff);
            update(tree,node*2+1, (start+end)/2+1, end, index, diff);
        }
    }
    
    long long sum(vector<long long> &tree, int node, int start, int end, int left, int right) {
        if (left > end || right < start) {
            return 0;
        }
        if (left <= start && end <= right) {
            return tree[node];
        }
        return sum(tree, node*2, start, (start+end)/2, left, right) + sum(tree, node*2+1, (start+end)/2+1, end, left, right);
    }
    
    int main() {
        ...
        vector<long long> a(n);
        int h = (int)ceil(log2(n));
        int tree_size = (1 << (h+1));
        vector<long long> tree(tree_size);
        ...
        return 0;
    }
    ```

# Fenwick Tree
- [참고1](https://www.acmicpc.net/blog/view/21){: target="_blank"}
- [참고2](https://www.crocus.co.kr/666){: target="_blank"}
- 펜윅 트리 혹은 이진 인덱스 트리(binary indexed tree)
  - 구간 합 대신 부분 합만을 빠르게 계산할 수 있는 자료구조를 만들어도 구간 합을 계산할 수 있는 알고리즘
  - n개의 수에 대한 부분 합을 n개의 숫자에 저장
  - 다른 부분합에 대해서 오른쪽 끝 위치의 이진수 표현에서 마지막 비트를 지우면 다음 구간을 쉽게 탐색
  - 맨 오른쪽에 있는 1인 비트를 스스로에게 더해 주는 연산을 반복하면 해당 위치를 포함하는 구간들을 모두 만날 수 있음
  - 계속 변하는 배열의 구간 합을 구할 때는 구간 트리보다 펜윅 트리를 자주 사용
  - 패턴
    ```c++
    long long sum(vector<long long> &tree, int i) {
        long long ans = 0;
        while (i > 0) {
            ans += tree[i];
            i -= (i & -i);
        }
        return ans;
    }
    
    void update(vector<long long> &tree, int i, long long diff) {
        while (i < tree.size()) {
            tree[i] += diff;
            i += (i & -i);
        }
    }
    
    int main() {
      ...
        vector<long long> a(n+1);
        vector<long long> tree(n+1);
        ...
    }
    ```

# Graph

- 그래프 G(V, E)는 어떤 자료나 개념을 표현하는 정점(vertex)들의 집합 V와 이들을 연결하는 간선(edge)들의 집합 E로 구성된 자료 구조
- 그래프의 종류
  - 방향 그래프(directed graph) or 유향 그래프 : 각 간선이 방향이라는 새로운 속성을 갖음
  - 무향 그래프(undirected graph) : 간선에 방향이 없는 그래프
  - 가중치 그래프(weighted graph) : 각 간선에 가중치(weight)라고 불리는 실수 속성을 부여
  - 다중 그래프(multi graph) : 두 정점 사이에 두 개 이상의 간선이 있을 수 있는 그래프
  - 단순 그래프(simple graph) : 두 정점 사이에 최대 한 개의 간선만 있는 그래프
  - 트리 or 루트 없는 트리(unrooted tree) : 부모 자식 관계가 없을 뿐, 간선들의 연결 관계만 보면 트리와 같은 무향 그래프
  - 이분 그래프(bipartite graph) : 그래프의 정점들을 겹치지 않는 두 개의 그룹으로 나눠서 서로 다른 그룹에 속한 정점들 간에만 간선이 존재하도록 만들 수 있는 그래프
  - 사이클 없는 방향 그래프(directed acyclic graph), DAG : 가중치 그래프 + 이분 가중치 그래프, 방향 그래프인데 한 점에서 출발해 자기 자신으로 돌아오는 경로(cycle)가 존자해지 않는 경우
- 그래프의 경로(path)
  - 그래프에서 사용되는 가장 중요한 개념
  - 끝과 끝이 서로 연결된 간선들을 순서대로 나열한 것
  - 뱡향 그래프의 경우, 앞 간선의 끝점이 뒷 간선의 시작점과 만나야 함
  - 단순 경로(simple path) : 경로 중 한 정점을 최대 한 번만 지나는 경로
  - 사이클(cycle) or 회로 : 시작한 점에서 끝나는 경로



```참고 : 알고리즘 문제 해결 전략```

