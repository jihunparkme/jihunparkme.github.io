---
layout: post
title: Algorithm_2
summary: Collect all algorithms
categories: Algorithm
featured-img: algorithms
# mathjax: true
---



# Table of Contents
* [Dynamic Programming](#Dynamic-Programming)

# Dynamic Programming
- 동적 계획법
  - 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용함으로써 속도의 향상를 꾀함
  - 두 번 이상 반복 계산되는 부분 문제들의 답을 미리 저장함으로써 속도의 향상을 꾀하는 알고리즘 설계 기법
    - 캐시(cache) : 이미 계산한 값을 저장해 두는 메모리의 장소
    - 중복되는 부분 문제(overlapping subproblems) : 두 번 이상 계산되는 부분 문제
- 메모이제이션(memoization) : 함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법, 메모이제이션은 참조적 투명 함수의 경우에만 적용 가능
  - 참조적 투명 함수(referential transparent function) : 입력이 고정되어 있을 떄, 그 결과가 항상 같은 함수
  - 메모이제이션의 패턴
  ```c++
  #include <iostream>
  
  using namespace std;
  
  int cache[2500][2500];
  
  // a와 b는 [0, 2500) 구간 안의 정수
  int someObsureFunction(int a, int b) {
  	// 기저 사례를 처음으로 처리.ex) 입력 범위를 벗어난 경우
  	if (...) return ...;
  	// (a,b)에 대한 답을 구한 적이 있으면 바로 반환
  	int& rst = cache[a][b];
  	if (rst != -1) return rst;
  	// 답 계산
  	...;
  	return rst;
  }
  
  int main() {
  	ios_base::sync_with_stdio(false);
  	cin.tie(NULL); cout.tie(NULL);
  
  	// memset()함수를 이용하여 cache 배열을 초기화
  	memset(cache, -1, sizeof(cache))
  }
  ```

#### [예제1](https://algospot.com/judge/problem/read/JUMPGAME){: target="_blank"}
- first. 주어진 문제를 (재귀적으로 해결하는) 완전 탐색을 이용하여 해결
  ```c++
  const int MAX = 100;
  int n, board[MAX][MAX];
  
  bool jump(int y, int x) {
  	// 기저 사례 : 게임판 밖을 벗어난 경우
  	if (y >= n || x >= n) return false;
  	// 기저 사례 : 마지막 칸에 도달한 경우
  	if (y == n - 1 && x == n - 1) return true;
      
  	int jumpSize = board[y][x];
  	return jump(y + jumpSize, x) || jump(y, x + jumpSize);
  }
  ```
- second. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션 적용
  - 완전 탐색 과정에서 중복으로 연산이 되는 부분들이 있는데, 
    이미 해결된 부분 문제들의 결과를 cache에 저장해주면서(메모이제이션 적용) 중복된 연산을 줄여줄 수 있음
  ```c++
  const int MAX = 100;
  int n, board[MAX][MAX];
  int cache[MAX][MAX];
  
  bool jump_mmz(int y, int x) {
  	// 기저 사례 : 게임판 밖을 벗어난 경우
  	if (y >= n || x >= n) return 0;
  	// 기저 사례 : 마지막 칸에 도달한 경우
  	if (y == n - 1 && x == n - 1) return 1;
  
  	// 메모이제이션 적용
  	int& rst = cache[y][x];
  	if (rst != -1) return rst;
  	
  	int jumpSize = board[y][x];
  	return rst = jump_mmz(y + jumpSize, x) || jump_mmz(y, x + jumpSize);
  }
  ```

  







```참고 : 알고리즘 문제 해결 전략```

