---
layout: post
title: Algorithm_2
summary: Collect all algorithms
categories: Algorithm
featured-img: algorithms
# mathjax: true
---

# Table of Contents
* [Dynamic Programming](#Dynamic-Programming)
* [Segment Tree](#Segment Tree)
# Dynamic Programming
- 동적 계획법
  - 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용함으로써 속도의 향상를 꾀함
  - 두 번 이상 반복 계산되는 부분 문제들의 답을 미리 저장함으로써 속도의 향상을 꾀하는 알고리즘 설계 기법
    - 캐시(cache) : 이미 계산한 값을 저장해 두는 메모리의 장소
    - 중복되는 부분 문제(overlapping subproblems) : 두 번 이상 계산되는 부분 문제
- 메모이제이션(memoization) : 함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법, 메모이제이션은 참조적 투명 함수의 경우에만 적용 가능
  - 참조적 투명 함수(referential transparent function) : 입력이 고정되어 있을 떄, 그 결과가 항상 같은 함수
  - 메모이제이션의 패턴
  ```c++
  #include <iostream>
  
  using namespace std;
  
  int cache[2500][2500];
  
  // a와 b는 [0, 2500) 구간 안의 정수
  int someObsureFunction(int a, int b) {
  	// 기저 사례를 처음으로 처리.ex) 입력 범위를 벗어난 경우
  	if (...) return ...;
  	// (a,b)에 대한 답을 구한 적이 있으면 바로 반환
  	int& rst = cache[a][b];
  	if (rst != -1) return rst;
  	// 답 계산
  	...;
  	return rst;
  }
  
  int main() {
  	ios_base::sync_with_stdio(false);
  	cin.tie(NULL); cout.tie(NULL);
  
  	// memset()함수를 이용하여 cache 배열을 초기화
  	memset(cache, -1, sizeof(cache))
  }
  ```

#### [예제]
[문제 1 : JUMPGAME](https://algospot.com/judge/problem/read/JUMPGAME){: target="_blank"}

- first. 주어진 문제를 (재귀적으로 해결하는) 완전 탐색을 이용하여 해결
  ```c++
  const int MAX = 100;
  int n, board[MAX][MAX];
  
  bool jump(int y, int x) {
  	// 기저 사례 : 게임판 밖을 벗어난 경우
  	if (y >= n || x >= n) return false;
  	// 기저 사례 : 마지막 칸에 도달한 경우
  	if (y == n - 1 && x == n - 1) return true;
      
  	int jumpSize = board[y][x];
  	return jump(y + jumpSize, x) || jump(y, x + jumpSize);
  }
  ```
- second. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션 적용
  - 완전 탐색 과정에서 중복으로 연산이 되는 부분들이 있는데, 
    이미 해결된 부분 문제들의 결과를 cache에 저장해주면서(메모이제이션 적용) 중복된 연산을 줄여줄 수 있음
  ```c++
  
  int n, board[MAX][MAX];
  int cache[MAX][MAX];
  
  bool jump_mmz(int y, int x) {
  	// 기저 사례 : 게임판 밖을 벗어난 경우
  	if (y >= n || x >= n) return 0;
  	// 기저 사례 : 마지막 칸에 도달한 경우
  	if (y == n - 1 && x == n - 1) return 1;
  
  	// 메모이제이션 적용
  	int& rst = cache[y][x];
  	if (rst != -1) return rst;
  	
  	int jumpSize = board[y][x];
  	return rst = jump_mmz(y + jumpSize, x) || jump_mmz(y, x + jumpSize);
  }
  ```

[문제 2 : WILDCARD](https://algospot.com/judge/problem/read/WILDCARD){: target="_blank"}

- ```c++
  #include <iostream>
  #include <string>
  
  int cache[101][101];
  
  string W, S;
  
  bool matchMemoized(int w, int s) {
  	int &ret = cache[w][s];
  	if (ret != -1) return ret;
  
  	// W[w]와 S[s] 비교
  	while (s < S.size() && w < W.size() &&
  		(W[w] == '?' || W[w] == S[s])) {
          // 첫 한 글자씩 떼고 남은 문자열이 서로 대응되는지 재귀 호출로 탐색
  		return ret = matchMemoized(w + 1, s + 1);
  	}
  	
  	// 더 이상 대응할 수 없으면 왜 while문이 끝났는지 확인
  	// 2. 패턴 끝에 도달
  	if (w == W.size()) return ret = (s == S.size());
  
  	// 4. *를 만나서 끝난 경우 : *에 몇 글자를 대응해야 할지
  	if (W[w] == '*') {
  		if (matchMemoized(w + 1, s) ||
  			(s < S.size() && matchMemoized(w, s + 1)))
              // *에 아무 글자도 대응시키지 않을 것인지 || 한 글자를 더 대응시킬 것인지 결정
  			return ret = 1;
  	}
  
  	// 3. 이 외의 경우에는 모두 대응되지 않음
  	return ret = 0;
  }
  ```
  
# Segment Tree

- [참고](#https://www.acmicpc.net/blog/view/9){: target="_blank"}
- 구간 트리 : 구간에 대한 질문 대답하기
  - 저장된 자료들을 적절히 전처리해 그들에 대한 질의들을 빠르게 대답할 수 있도록 함
  - 흔히 일차원 배열의 특정 구간에 대한 질문을 빠르게 대답하는데 사용
  - 루드 노드를 배열의 1번 원소로, 노드 i의 왼쪽 자손과 오른쪽 자손을 각각 2 x i 와 2 x i + 1 번 원소로 표현
  - 높이는 log2N의 올림이고, 세그먼트 트리를 만드는데 필요한 배열의 크기는 2^(H+1) - 1
  - 패턴
    ```c++
    long long init(vector<long long> &a, vector<long long> &tree, int node, int start, int end) {
        if (start == end) {
            return tree[node] = a[start];
        } else {
            return tree[node] = init(a, tree, node*2, start, (start+end)/2) + init(a, tree, node*2+1, (start+end)/2+1, end);
        }
    }
    
    void update(vector<long long> &tree, int node, int start, int end, int index, long long diff) {
        if (index < start || index > end) return;
        tree[node] = tree[node] + diff;
        if (start != end) {
            update(tree,node*2, start, (start+end)/2, index, diff);
            update(tree,node*2+1, (start+end)/2+1, end, index, diff);
        }
    }
    
    long long sum(vector<long long> &tree, int node, int start, int end, int left, int right) {
        if (left > end || right < start) {
            return 0;
        }
        if (left <= start && end <= right) {
            return tree[node];
        }
        return sum(tree, node*2, start, (start+end)/2, left, right) + sum(tree, node*2+1, (start+end)/2+1, end, left, right);
    }
    
    int main() {
        ...
        vector<long long> a(n);
        int h = (int)ceil(log2(n));
        int tree_size = (1 << (h+1));
        vector<long long> tree(tree_size);
        ...
        return 0;
    }
    ```

# Fenwick Tree
- [참고1](https://www.acmicpc.net/blog/view/21){: target="_blank"}
- [참고2](https://www.crocus.co.kr/666){: target="_blank"}
- 펜윅 트리 혹은 이진 인덱스 트리(binary indexed tree)
  - 구간 합 대신 부분 합만을 빠르게 계산할 수 있는 자료구조를 만들어도 구간 합을 계산할 수 있는 알고리즘
  - n개의 수에 대한 부분 합을 n개의 숫자에 저장
  - 다른 부분합에 대해서 오른쪽 끝 위치의 이진수 표현에서 마지막 비트를 지우면 다음 구간을 쉽게 탐색
  - 맨 오른쪽에 있는 1인 비트를 스스로에게 더해 주는 연산을 반복하면 해당 위치를 포함하는 구간들을 모두 만날 수 있음
  - 계속 변하는 배열의 구간 합을 구할 때는 구간 트리보다 펜윅 트리를 자주 사용
  - 패턴
    ```c++
    long long sum(vector<long long> &tree, int i) {
        long long ans = 0;
        while (i > 0) {
            ans += tree[i];
            i -= (i & -i);
        }
        return ans;
    }
    
    void update(vector<long long> &tree, int i, long long diff) {
        while (i < tree.size()) {
            tree[i] += diff;
            i += (i & -i);
        }
    }
    
    int main() {
      ...
        vector<long long> a(n+1);
        vector<long long> tree(n+1);
        ...
    }
    ```
  
    





```참고 : 알고리즘 문제 해결 전략```

