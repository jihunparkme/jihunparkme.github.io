---
layout: post
title: Start DDD
summary: 도메인 주도 개발 시작하기
categories: (Book)DDD
featured-img: start-ddd
---

# 도메인 주도 개발 시작하기

[Example Code](https://github.com/madvirus/ddd-start2)

# 도메인 모델

**도메인 전문가와 개발자 간 지식 공유**

- Garbage in, Garbage out
> 개발자는 요구사항을 이해할 때 `왜 이러한 기능을 요구하는지` 또는 `실제로 원하는 게 무엇인지` 생각하고 전문가와 대화를 통해 진짜로 원하는 것을 찾아야 한다.

.

**도메인 모델**

- 도메인 모델은 아키텍처 상의 도메인 계층을 `객체 지향 기법으로 구현`하는 패턴
- 도메인 모델을 사용하면 여러 관계자들이 `동일한 모습으로 도메인을 이해`하고 도메인 지식을 공유하는 데 도움이 된다.
- 핵심 규칙을 구현한 코드는 `도메인 모델에만 위치`하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반경할 수 있다.

.

**도메인 모델 도출**

- 도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 `핵심 구성요소`, `규칙`, `기능`을 찾는 것.
- ex)
  - 최소 한 종류 이상의 상품을 주문해야 한다.
  - ...
  - 출고를 하면 배송지를 변경할 수 없다.
  
> 코드를 보면서 도메인을 깊게 이해하게 되므로 코드 자체도 문서화의 대상.
>
> 단순히 코드를 보기 좋게 작성하는 것뿐만 아니라 도메인 관점에서 코드가 도메인을 잘 표현해야 비로소 코드의 가독성이 높아지고 문서로서 코드가 의미를 갖는다.

.

**엔티티와 밸류**

- 엔티티
  - 식별자를 가진다(식별자는 엔티티 객체마다 고유해서 각 엔티티는 서로 다른 식별자를 보유)
  - 엔티티의 식별자는 변경되지 않고 고유하므로 두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단

Order.java

```java
@Entity
@Getter
@Table(name = "purchase_order")
@Access(AccessType.FIELD)
public class Order {
    @EmbeddedId
    private OrderNo number;

    @Version
    private long version;

    @Embedded
    private Orderer orderer;

    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "order_line", joinColumns = @JoinColumn(name = "order_number"))
    @OrderColumn(name = "line_idx")
    private List<OrderLine> orderLines;

    @Convert(converter = MoneyConverter.class)
    @Column(name = "total_amounts")
    private Money totalAmounts;

    @Embedded
    private ShippingInfo shippingInfo;

    @Column(name = "state")
    @Enumerated(EnumType.STRING)
    private OrderState state;

    @Column(name = "order_date")
    private LocalDateTime orderDate;

    protected Order() {
    }

    public Order(OrderNo number, Orderer orderer, List<OrderLine> orderLines,
                 ShippingInfo shippingInfo, OrderState state) {
        setNumber(number);
        setOrderer(orderer);
        setOrderLines(orderLines);
        setShippingInfo(shippingInfo);
        this.state = state;
        this.orderDate = LocalDateTime.now();
        Events.raise(new OrderPlacedEvent(number.getNumber(), orderer, orderLines, orderDate));
    }

    private void setNumber(OrderNo number) {
        if (number == null) throw new IllegalArgumentException("no number");
        this.number = number;
    }

    private void setOrderer(Orderer orderer) {
        if (orderer == null) throw new IllegalArgumentException("no orderer");
        this.orderer = orderer;
    }

    private void setOrderLines(List<OrderLine> orderLines) {
        verifyAtLeastOneOrMoreOrderLines(orderLines);
        this.orderLines = orderLines;
        calculateTotalAmounts();
    }

    // 요구사항: 적어도 한 개 이상의 상품을 주문할 수 있다.
    private void verifyAtLeastOneOrMoreOrderLines(List<OrderLine> orderLines) {
        if (orderLines == null || orderLines.isEmpty()) {
            throw new IllegalArgumentException("no OrderLine");
        }
    }

    // 요구사항: 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액
    private void calculateTotalAmounts() {
        this.totalAmounts = new Money(orderLines.stream()
                .mapToInt(x -> x.getAmounts().getValue()).sum());
    }

    private void setShippingInfo(ShippingInfo shippingInfo) {
        if (shippingInfo == null) throw new IllegalArgumentException("no shipping info");
        this.shippingInfo = shippingInfo;
    }

    // 요구사항: 출고를 하면 배송지를 변경할 수 없다.
    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        verifyNotYetShipped(); // 발송 전 상태인가?
        setShippingInfo(newShippingInfo);
        Events.raise(new ShippingInfoChangedEvent(number, newShippingInfo));
    }

    // 요구사항: 출고를 하면 배송지를 변경할 수 없다.
    public void cancel() {
        verifyNotYetShipped();  // 발송 전 상태인가?
        this.state = OrderState.CANCELED;
        Events.raise(new OrderCanceledEvent(number.getNumber()));
    }

    private void verifyNotYetShipped() {
        if (!isNotYetShipped())
            throw new AlreadyShippedException();
    }

    public boolean isNotYetShipped() {
        return state == OrderState.PAYMENT_WAITING || state == OrderState.PREPARING;
    }

    public boolean matchVersion(long version) {
        return this.version == version;
    }
    
    // 요구사항: 발송 시작
    public void startShipping() { 
        verifyShippableState();
        this.state = OrderState.SHIPPED;
        Events.raise(new ShippingStartedEvent(number.getNumber()));
    }

    // 발송 가능한 상태인가?
    private void verifyShippableState() {
        verifyNotYetShipped(); // 발송 전 상태인가?
        verifyNotCanceled(); // 취소되지 않은 상태인가?
    }

    private void verifyNotCanceled() {
        if (state == OrderState.CANCELED) {
            throw new OrderAlreadyCanceledException();
        }
    }
}
```

OrderLine.java

OrderState.java

ShippingInfo.java

.

# 아키텍처 개요

아키텍처 구성

|영역|설명|
|:---|:---|
|사용자 인터페이스 또는 표현(Presentation)|사용자의 요청을 처리하고 사용자에게 정보를 보여준다. 여기서 사용자는 소프트웨어를 사용하는 사람뿐만 아니라 외부 시스템일 수도 있음|
|응용(Application)|사용자가 요청한 기능을 실행. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행|
|도메인(Domain)|시스템이 제공할 도메인 규칙을 구현|
|인프라스트럭처(Infrastructure)|데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리|

# 애그리거트

# 리포지터리와 모델

# 스피링 데이터 JPA

# 응용 서비스와 표현 영역

# 도메인 서비스

# 애그러기트 트랜잭션

# 도메인 모델과 바운디드 컨텍스트

# 이벤트

# CQRS