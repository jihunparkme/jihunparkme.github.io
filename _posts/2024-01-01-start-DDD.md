---
layout: post
title: Start DDD
summary: 도메인 주도 개발 시작하기
categories: (Book)DDD
featured-img: start-ddd
---

# 도메인 주도 개발 시작하기

[Example Code](https://github.com/jihunparkme/ddd-start2)

# 도메인 모델

**도메인**

- 소프트웨어로 해결하고자 하는 문제 영역.
- 한 도메인은 다시 하위 도메인으로 나뉠 수 있다.
- 도메인: 온라인 서점
  - 하위 도메인: 주문, 혜택, 회원, 정산, 결제, 배송, 카탈로그, 리뷰

**도메인 전문가와 개발자 간 지식 공유**

- Garbage in, Garbage out
> 개발자는 요구사항을 이해할 때 `왜 이러한 기능을 요구하는지` 또는 `실제로 원하는 게 무엇인지` 생각하고 전문가와 대화를 통해 진짜로 원하는 것을 찾아야 한다.

.

**도메인 모델**

![Result](https://github.com/jihunparkme/jihunparkme.github.io/blob/master/post_img/ddd-start/domain-model.jpg?raw=true 'Result')

- 도메인 모델은 아키텍처 상의 도메인 계층을 `객체 지향 기법으로 구현`하는 패턴
- 도메인 모델을 사용하면 여러 관계자들이 `동일한 모습으로 도메인을 이해`하고 도메인 지식을 공유하는 데 도움이 된다.
- 핵심 규칙을 구현한 코드는 `도메인 모델에만 위치`하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반경할 수 있다.

.

**도메인 모델 도출**

- 도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 `핵심 구성요소`, `규칙`, `기능`을 찾는 것.
- ex)
  - 최소 한 종류 이상의 상품을 주문해야 한다.
  - ...
  - 출고를 하면 배송지를 변경할 수 없다.
  
> 코드를 보면서 도메인을 깊게 이해하게 되므로 코드 자체도 문서화의 대상.
>
> 단순히 코드를 보기 좋게 작성하는 것뿐만 아니라 도메인 관점에서 코드가 도메인을 잘 표현해야 비로소 코드의 가독성이 높아지고 문서로서 코드가 의미를 갖는다.

.

**엔티티와 밸류**

엔티티 / [Order](https://github.com/jihunparkme/ddd-start2/blob/main/src/main/java/com/myshop/order/command/domain/Order.java)
- `식별자`를 가진다.(식별자는 엔티티 객체마다 고유해서 각 엔티티는 서로 다른 식별자를 보유, ex. 주문번호)
- 엔티티의 식별자는 변경되지 않고 고유하므로 두 엔티티 객체의 `식별자가 같으면` 두 엔티티는 같다고 판단.
- 식별자 생성.
  - 특정 규칙에 따라 생성
  - UUID, Nano ID 같은 고유 식별자 생성기 사용
  - 값 직접 입력
  - 일련번호 사용(시퀀스, DB 자동 증가 컬럼)

밸류 타입 / [ShippingInfo](https://github.com/jihunparkme/ddd-start2/blob/main/src/main/java/com/myshop/order/command/domain/ShippingInfo.java)
- 개념적으로 `완전한 하나`를 표현할 때 사용 / [Receiver](https://github.com/jihunparkme/ddd-start2/blob/main/src/main/java/com/myshop/order/command/domain/Receiver.java), [Address](https://github.com/jihunparkme/ddd-start2/blob/main/src/main/java/com/myshop/common/model/Address.java)
- 밸류 타입을 위한 `기능 추가` 가능 / [Money](https://github.com/jihunparkme/ddd-start2/blob/main/src/main/java/com/myshop/common/model/Money.java)
  - 밸류 객체 데이터를 변경할 때는 기존 데이터를 변경하기보다 변경한 데이터를 갖는 새로운 밸류 객체 생성 방식 선호.
- 두 밸류 객체를 비교할 때는 모든 속성이 같은지 비교.

엔티티 식별자와 밸류 타입
- 식별자를 위한 밸류 타입을 사용해서 의미가 잘 드러나도록 하자. 
  - `private OrderNo number;`

도메인 모델이 set 메서드 넣지 않기
- set 메서드는 필드값만 변경하고 끝나므로 상태 변경과 관련된 도메인 지식이 코드에서 사라지게 된다.
- 도메인 객체 생성 시 온전하지 않은 상태가 될 수 있다.
- 도메인 객체가 불완전한 상태로 사용되는 것을 막기 위해 `생성자를 통해 필요한 데이터`를 모두 받자.
- 밸류 타입은 불변으로 구현


```java
@Entity
@Getter
@Table(name = "purchase_order")
@Access(AccessType.FIELD)
public class Order {
    @EmbeddedId
    private OrderNo number;

    @Version
    private long version;

    @Embedded
    private Orderer orderer;

    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "order_line", joinColumns = @JoinColumn(name = "order_number"))
    @OrderColumn(name = "line_idx")
    private List<OrderLine> orderLines;

    @Convert(converter = MoneyConverter.class)
    @Column(name = "total_amounts")
    private Money totalAmounts;

    @Embedded
    private ShippingInfo shippingInfo;

    @Column(name = "state")
    @Enumerated(EnumType.STRING)
    private OrderState state;

    @Column(name = "order_date")
    private LocalDateTime orderDate;

    protected Order() {
    }

    public Order(OrderNo number, Orderer orderer, List<OrderLine> orderLines,
                 ShippingInfo shippingInfo, OrderState state) {
        setNumber(number);
        setOrderer(orderer);
        setOrderLines(orderLines);
        setShippingInfo(shippingInfo);
        this.state = state;
        this.orderDate = LocalDateTime.now();
        Events.raise(new OrderPlacedEvent(number.getNumber(), orderer, orderLines, orderDate));
    }

    private void setNumber(OrderNo number) {
        if (number == null) throw new IllegalArgumentException("no number");
        this.number = number;
    }

    private void setOrderer(Orderer orderer) {
        if (orderer == null) throw new IllegalArgumentException("no orderer");
        this.orderer = orderer;
    }

    private void setOrderLines(List<OrderLine> orderLines) {
        verifyAtLeastOneOrMoreOrderLines(orderLines);
        this.orderLines = orderLines;
        calculateTotalAmounts();
    }

    // 요구사항: 최소 한 종류 이상의 상품을 주문해야 한다.
    private void verifyAtLeastOneOrMoreOrderLines(List<OrderLine> orderLines) {
        if (orderLines == null || orderLines.isEmpty()) {
            throw new IllegalArgumentException("no OrderLine");
        }
    }

    // 요구사항: 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액
    private void calculateTotalAmounts() {
        this.totalAmounts = new Money(orderLines.stream()
                .mapToInt(x -> x.getAmounts().getValue()).sum());
    }

    private void setShippingInfo(ShippingInfo shippingInfo) {
        if (shippingInfo == null) throw new IllegalArgumentException("no shipping info");
        this.shippingInfo = shippingInfo;
    }

    // 요구사항: 출고를 하면 배송지를 변경할 수 없다.
    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        verifyNotYetShipped();
        setShippingInfo(newShippingInfo);
        Events.raise(new ShippingInfoChangedEvent(number, newShippingInfo));
    }

    // 요구사항: 출고 전에 주문을 취소할 수 있다.
    public void cancel() {
        verifyNotYetShipped();
        this.state = OrderState.CANCELED;
        Events.raise(new OrderCanceledEvent(number.getNumber()));
    }

    // 출고 전 상태인지 확인
    private void verifyNotYetShipped() {
        if (!isNotYetShipped())
            throw new AlreadyShippedException();
    }

    // 요구사항: 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.
    public boolean isNotYetShipped() {
        return state == OrderState.PAYMENT_WAITING || state == OrderState.PREPARING;
    }

    public boolean matchVersion(long version) {
        return this.version == version;
    }
    
    // 요구사항: 발송 시작
    public void startShipping() { 
        verifyShippableState();
        this.state = OrderState.SHIPPED;
        Events.raise(new ShippingStartedEvent(number.getNumber()));
    }

    // 발송 가능한 상태인지 확인
    private void verifyShippableState() {
        verifyNotYetShipped();
        verifyNotCanceled();
    }

    // 취소되지 않은 상태인지 확인
    private void verifyNotCanceled() {
        if (state == OrderState.CANCELED) {
            throw new OrderAlreadyCanceledException();
        }
    }
}
```

.

# 아키텍처 개요

아키텍처 구성

|영역|설명|
|:---|:---|
|사용자 인터페이스 또는 표현(Presentation)|사용자의 요청을 처리하고 사용자에게 정보를 보여준다. 여기서 사용자는 소프트웨어를 사용하는 사람뿐만 아니라 외부 시스템일 수도 있음|
|응용(Application)|사용자가 요청한 기능을 실행. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행|
|도메인(Domain)|시스템이 제공할 도메인 규칙을 구현|
|인프라스트럭처(Infrastructure)|데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리|

# 애그리거트

# 리포지터리와 모델

# 스피링 데이터 JPA

# 응용 서비스와 표현 영역

# 도메인 서비스

# 애그러기트 트랜잭션

# 도메인 모델과 바운디드 컨텍스트

# 이벤트

# CQRS