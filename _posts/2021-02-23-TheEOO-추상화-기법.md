---
layout: post
title: 부록. 추상화 기법
summary: 추상화 기법
categories: (Book)객체지향의-사실과-오해
featured-img: TheEOO
# mathjax: true
---

# 부록. 추상화 기법

## 추상화 기법

- 추상화는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단

- 추상화 기법
  - ***분류와 인스턴스화*** : 
    - `분류`는 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정
    - 분류의 역은 범주로부터 객체를 생성하는 `인스턴스화 과정`
  - ***일반화와 특수화*** : 
    - `일반화`는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조
    - 일반화의 역을 `특수화`
  - ***집합과 분해*** : 
    - `집합`은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정
    - 집합의 반대 과정은 전체를 부분으로 분리하는 `분해 과정`

## 분류와 인스턴스화

**개념과 범주**

- 객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것을 의미
- `개념`이란 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어
- 세상에 존재하는 객체에 개념을 적용하는 과정을 `분류`
- 수많은 개별적인 현상들을 `객체`라고 하고, 하나의 개념을 `타입`이라고 한다.
- 분류의 역은 타입에 해당하는 객체를 생성하는 과정 `인스턴스화` or `예시`

- `분류`는 
  - 객체를 타입과 연관시키는 것
  - 객체들을 동일한 타입 또는 범주로 묶는 과정
  - 객체와 타입 간의 관계를 나타낸 것.

**타입**

- 객체를 타입에 따라 분류하기 위해서는 객체가 타입에 속하는지 여부를 확인할 수 있어야 한다.
- 타입을 객체의 분류 장치로 적용하기 위한 정의
  - `심볼`: 타입을 가리키는 <u>*간략한 이름이나 명칭*</u>
  - `내연`: 타입의 완전한 정의, 내연의 의미를 이용해 <u>*객체가 타입에 속하는지 여부*</u>를 확인
  - `외연`: 타입에 속하는 <u>*모든 객체들의 집합*</u>

**외연과 집합**

- 단일 분류 : 한 객체가 한 시점에 하나의 타입에만 속하는 것
- 다중 분류 : 한 객체가 한 시점에 여러 타입에 속할 경우
- 동적 분류 : 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있을 경우
- 정적 분류 : 객체가 자신의 타입을 변경할 수 없는 경우

> 다중 분류와 정적 분류 방식으로 객체들의 범주를 재조정하는 편이 분석과 구현 간의 차이를 메울 수 있는 가장 현실적인 방법
> 단순함을 위해서는 항상 다중 분류와 동적 분류보다는 단일 분류와 정적 분류를 선택하는 것이 현명

**클래스**

## 일반화와 특수화

**범주의 계층**

- 계층의 상위에 위치한 범주를 계층의 하위에 위치한 범주의 `일반화`라고 하고,
- 계층의 하위에 위치한 범주는 계층의 상위에 위치한 범주의 `특수화`라고 한다.

**서브타입**

- 어떤 타입이 다른 타입보다 일반적이라면 `슈퍼타입`
- 어떤 타입이 다른 타입보다 좀 더 특수하다면 `서브타입`
- 슈퍼 타입은 서브타입의 `일반화`이고, 서브타입은 슈퍼타입의 `특수화`

- `100% 규칙` : 슈퍼타입의 정의가 100% 서브타입에 적용돼야 한다.
  - 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치
- `is-a 규칙` : 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다.
- `is-a-kind-of` : 서브타입이 슈퍼타입 정의를 확장하는 경우

**상속**

- 일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응해야 한다
  - 구조적인 순응 : 타입의 내연과 관련된 100% 규칙을 의미한다.
  - 행위적인 순응 : 타입의 행위에 관한 것. 서브타입은 슈퍼타입의 행위적으로 대체 가능해야 한다.

- 상속의 용도
  - 서브타이핑 : 서브클래스가 슈퍼클래스를 대체할 수 <u>*있는*</u> 경우 (유연성이 목표)
    - 인터페이스 상속(Interface inheritance)이라고 불림
    - 특정 기대 집합에 대한 서브타입과 슈퍼타입 간의 구조적, 또는 행위적 순응 관계
    - 대체 가능성을 내포
  - 서브클래싱 : 서브클래스가 슈퍼클래스를 대체할 수 <u>*없는*</u> 경우 (코드 중복 제거와 재사용 목적)
      - 구현 상속(Implementation inheritance)이라고 불림
    - 서브클래스가 슈퍼클래스를 대체할 수 없고 단지 코드만 공유하고 있다면 서브클래싱
  